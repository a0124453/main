# A0114240B
###### /src/lifetracker/ui/README.css
``` css
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px;
  color: #333;
}
```
###### /src/lifetracker/ui/UiDesign.fxml
``` fxml

<AnchorPane xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="lifetracker.ui.UiController">
   <children>
      <VBox alignment="TOP_CENTER" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" spacing="2.5" style="-fx-background-color: transparent;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
         <children>
            <AnchorPane VBox.vgrow="NEVER">
               <children>
                  <Label fx:id="labelTitle" alignment="CENTER" contentDisplay="CENTER" text="LIFE TRACKER" textAlignment="CENTER" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <font>
                        <Font name="Lato Bold" size="36.0" />
                     </font>
                  </Label>
               </children>
            </AnchorPane>
            <AnchorPane maxHeight="1.7976931348623157E308" VBox.vgrow="ALWAYS">
               <children>
                  <StackPane maxHeight="1.7976931348623157E308" style="-fx-background-color: transparent;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <children>
                        <WebView fx:id="webView" prefHeight="-1.0" prefWidth="-1.0" />
                        <VBox alignment="TOP_CENTER" spacing="10.0" style="-fx-background-color: transparent;" StackPane.alignment="TOP_CENTER">
                           <children>
                              <TableView fx:id="tableEvent" prefHeight="225.0" VBox.vgrow="ALWAYS">
                                <placeholder>
        					    	<Label text="No event taking place today:)"/>
    							</placeholder>
                                <columns>
                                    <TableColumn fx:id="columnEventStartTime" editable="false" maxWidth="200.0" minWidth="2.0" prefWidth="200.0" resizable="false" sortable="false" text="START TIME" />
                                    <TableColumn fx:id="columnEventEndTime" editable="false" maxWidth="200.0" minWidth="2.0" prefWidth="200.0" resizable="false" sortable="false" text="END TIME" />
                                  <TableColumn fx:id="columnEventName" editable="false" minWidth="0.0" prefWidth="340.0" resizable="false" sortable="false" text="EVENT" />
                                  <TableColumn fx:id="columnEventId" editable="false" maxWidth="60.0" prefWidth="60.0" resizable="false" sortable="false" text="#ID" />
                                    <TableColumn fx:id="columnEventRecurring" editable="false" maxWidth="250.0" minWidth="0.0" prefWidth="265.0" resizable="false" sortable="false" text="EVERY" />
                                </columns>
                              </TableView>
                              <TableView fx:id="tableTask" prefHeight="225.0" VBox.vgrow="ALWAYS">
                                 <placeholder>
        					     	<Label text="No task due today:)"/>
    							 </placeholder>
                                 <columns>
                                    <TableColumn fx:id="columnTaskTime" editable="false" maxWidth="400.0" minWidth="2.0" prefWidth="400.0" resizable="false" sortable="false" text="TIME" />
                                    <TableColumn fx:id="columnTaskName" editable="false" maxWidth="340.0" prefWidth="340.0" resizable="false" sortable="false" text="TASK" />
                                    <TableColumn fx:id="columnTaskId" editable="false" maxWidth="60.0" prefWidth="60.0" resizable="false" sortable="false" text="#ID" />
                                    <TableColumn fx:id="columnTaskRecurring" editable="false" maxWidth="250.0" minWidth="2.0" prefWidth="265.0" resizable="false" sortable="false" text="EVERY" />
                                 </columns>
                              </TableView>
                           </children>
                        </VBox>
                     </children>
                  </StackPane>
               </children>
            </AnchorPane>
            <AnchorPane maxHeight="-Infinity" VBox.vgrow="NEVER">
               <children>
                  <Label fx:id="labelFeedback" alignment="CENTER" contentDisplay="CENTER" prefHeight="80.0" prefWidth="923.0" text="Welcome to the Life Tracker, Spend less time planning so you always know what's next." textAlignment="CENTER" wrapText="true" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0">
                     <font>
                        <Font name="Lato Regular" size="24.0" />
                     </font>
                  </Label>
               </children>
            </AnchorPane>
            <AnchorPane maxHeight="-Infinity" VBox.vgrow="NEVER">
               <children>
                  <TextField fx:id="textInput" alignment="CENTER" onAction="#getInput" prefHeight="0.0" promptText="Enter Command" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <font>
                        <Font name="Lato Light" size="24.0" />
                     </font>
                  </TextField>
               </children>
            </AnchorPane>
         </children>
         <padding>
            <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         </padding>
      </VBox>
   </children>
</AnchorPane>
```
###### /src/lifetracker/ui/application.css
``` css
@font-face {
	src: url('/lifetracker/ui/Lato-Regular.ttf');
}

.root {
	-fx-font-family: "Lato-Regular";
}

#labelTitle {
	-fx-background-color: #4B77BE;
	-fx-border-radius: 5 5 5 5;
    -fx-background-radius: 5 5 5 5;
    -fx-text-fill: white;
}

#textInput {
	-fx-prompt-text-fill: derive(-fx-control-inner-background,-30.0%);
}

.table-column {
	-fx-alignment: CENTER;
}

#columnTaskName, #columnEventName {
	-fx-alignment: CENTER-LEFT;
	-fx-padding: 0 0 0 15;
}

.table-view .placeholder .label {
	-fx-font-family: 'Lato-Bold'; 
    -fx-font-size: 20px;  
}

.table-view .column-header .label { 
	-fx-font-family: 'Lato-Bold'; 
    -fx-font-size: 16px;  
    -fx-font-weight: bold;      
    -fx-text-fill: white;  
    -fx-alignment: center-left;   
    -fx-padding: 5.0 5.0 5.0 5.0;  
    -fx-alignment: CENTER;
}  

.table-view .column-header {
	-fx-background-color: #89C4F4;
	-fx-border-radius: 5 5 0 0;
    -fx-background-radius: 5 5 0 0;
    -fx-pref-height: 45.0px;
} 

.table-view .filler{  
    -fx-background-radius: 0.0 5.0 0.0 0.0;    
    -fx-background-color: #89C4F4;      
    -fx-size: 45.0px;  
    -fx-min-height: 45.0px;      
}  

.table-view .placeholder{  
     -fx-background-color: white;      
}  

.table-view {
	-fx-background-color: transparent;
	-fx-border-color: black;
	-fx-border-width: 0.5px;
	-fx-border-radius: 5 5 5 5;
    -fx-background-radius: 5 5 5 5; 
}

.table-view .column-header-background {  
    -fx-background-radius: 5.0 5.0 0.0 0.0;  
    -fx-background-color: #89C4F4;  
} 

/* EACH ROW */
.table-row-cell {      
    -fx-border-width: 0;     
    -fx-pref-height: 45.0px;  
    -fx-font-size: 14px; 
    -fx-background-radius: 5 5 5 5; 
    -fx-border-radius: 5 5 5 5;
}  

.table-row-cell .table-column{  
    -fx-border-width: 1px;          
}  

.table-row-cell:overdue {
 	-fx-background-color: rgba(255, 159, 160, .4);
}

.table-row-cell:new {
 	-fx-background-color: rgba(0, 255, 0, .4);
}

.table-row-cell:done .text {
 	-fx-strikethrough: true;
}
  

/* HIDE HORIZONTAL SCROLLBAR */
.table-view .scroll-bar:horizontal .increment-button,
.table-view .scroll-bar:horizontal .decrement-button {
    -fx-background-color: null;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-padding: 0;
}

.table-view .scroll-bar:horizontal .increment-arrow, 
.table-view .scroll-bar:horizontal .decrement-arrow {
    -fx-background-color: null;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-padding: 0;
    -fx-shape: null;
}

/*
#columnTaskID, #columnEventID {
	-fx-border-radius: 10 0 0 0;
    -fx-background-radius: 10 0 0 0;
}

#columnTaskRecurring, #columnEventRecurring {
	-fx-border-radius: 0 10 0 0;
    -fx-background-radius: 0 10 0 0;
}*/
```
###### /src/lifetracker/ui/UiController.java
``` java
/**
 * This class is the main controller for the User Interface (UI) of LifeTracker.
 * The user interface design that this class is controlling can be found
 * inside the file /lifetracker/ui/UiDesign.fxml. All functions that relate
 * user action to the Logic Class can be found here.
 */
public class UiController implements Initializable {
    /** Variables used for logging */
    private static final Logger STORE_LOG = Logger.getGlobal();
    private static final String LOG_STARTUP = "UI: Starting";
    private static final String LOG_SHUTDOWN = "UI: Exiting";
    
    /** Constant variables to avoid magic number/string */
    private static final String PATH_README_CSS = "/lifetracker/ui/README.css";
    private static final String PATH_README_HTML = "/lifetracker/ui/README.html";
    private static final String FIELD_EMPTY = "";
    private static final String FIELD_DAY = "day(s)";
    private static final String FIELD_MONTH = "month(s)";
    private static final String FIELD_YEAR = "year(s)";
    private static final String FIELD_MINUTE = "minute(s)";
    private static final String FIELD_HOUR = "hour(s)";
    private static final String FIELD_LIMIT_OCCUR_SUFFIX = " time(s)";
    private static final String FIELD_LIMIT_OCCUR_PREFIX = " for ";
    private static final String FIELD_LIMIT_DATE = " until ";
    private static final PseudoClass PSEUDO_CLASS_OVERDUE = PseudoClass.getPseudoClass("overdue");
    private static final PseudoClass PSEUDO_CLASS_DONE = PseudoClass.getPseudoClass("done");
    private static final PseudoClass PSEUDO_CLASS_NEW = PseudoClass.getPseudoClass("new");

    private static Logic l;
    private static List<String> inputHistory;
    private static int inputHistoryIndex;
    private static ObservableList<LogicTask> taskList = FXCollections.observableArrayList();
    private static ObservableList<LogicEvent> eventList = FXCollections.observableArrayList();
    private static WebEngine webEngine;

    /** Variables linked to UiDesign.fxml */
    @FXML
    Label labelTitle;
    @FXML
    TextField textInput;
    @FXML
    Label labelFeedback;
    @FXML
    TableView<LogicTask> tableTask;
    @FXML
    TableColumn<LogicTask, String> columnTaskId;
    @FXML
    TableColumn<LogicTask, String> columnTaskName;
    @FXML
    TableColumn<LogicTask, String> columnTaskTime;
    @FXML
    TableColumn<LogicTask, String> columnTaskRecurring;
    @FXML
    TableView<LogicEvent> tableEvent;
    @FXML
    TableColumn<LogicEvent, String> columnEventId;
    @FXML
    TableColumn<LogicEvent, String> columnEventName;
    @FXML
    TableColumn<LogicEvent, String> columnEventStartTime;
    @FXML
    TableColumn<LogicEvent, String> columnEventEndTime;
    @FXML
    TableColumn<LogicEvent, String> columnEventRecurring;
    @FXML
    WebView webView;

    /**
     * Initialize all the variables that are linked to UIDesign.fxml.
     * These variables are linked to various UI components of LifeTracker.
     */
    @Override
    public void initialize(URL location, ResourceBundle resources) {
        initLog();
        initTabBehaviour();
        initWebView();
        initInputHistory();
        initTableTask();
        initTableEvent();
        initTextInputKeyDetection();
        focusTextInput();
    }
    
    /**
     * Logging when the UI is launched
     */
    private void initLog() {
        STORE_LOG.log(Level.INFO, LOG_STARTUP);
    }

    /**
     * Get the input from <TextField> textInput when user press enter.
     * This method is linked to textInput component in the UI via UiDesign.fxml.
     */
    @FXML
    public void getInput() {
        String userInput = textInput.getText();
        addInputToHistory(userInput);
        process(userInput);
        textInput.setText(FIELD_EMPTY);
    }
    
    /**
     * Return Logic object.
     * The Logic object can never be null, thus assertion is used.
     * 
     * @return  Logic object.
     */
    public Logic getLogic() {
        assert l != null;
        return l;
    }

    /**
     * Set the Logic object that will be used in various functions under this class.
     * The Logic object can never be null, thus assertion is used.
     * 
     * @param l Logic object.
     */
    public void setLogic(Logic l) {
        assert l != null;
        UiController.l = l;
    }
    
    /**
     * Initialize how the behavior works when user press TAB button.
     * User can only switch from textInput to tableEvent to tableTask and not the
     * rest of the UI component.
     */
    private void initTabBehaviour() {
        textInput.setFocusTraversable(true);
        tableEvent.setFocusTraversable(true);
        tableTask.setFocusTraversable(true);
        webView.setFocusTraversable(true);
        labelFeedback.setFocusTraversable(false);
        labelTitle.setFocusTraversable(false);
    }
    
    /**
     * Initialize the webView and load it with README.html.
     * README.html can be found in /lifetracker/ui/README.html. The initial visibility
     * is set to false since webView is loaded behind tableTask and tableEvent.
     */
    private void initWebView() {
        String htmlURL = LifeTracker.class.getResource(PATH_README_HTML).toExternalForm();
        String cssURL = LifeTracker.class.getResource(PATH_README_CSS).toString();
        webEngine = webView.getEngine();
        webEngine.setUserStyleSheetLocation(cssURL);
        webEngine.load(htmlURL);
        webView.setVisible(false);
    }
    
    /**
     * Initialize the array inputHistory to keep track of the user input.
     */
    private void initInputHistory() {
        inputHistory = new ArrayList<String>();
        inputHistoryIndex = -1;
    }
    
    /**
     * Initialize tableTask.
     * This method initialize tableTask by indicating what field to be
     * put inside each cell.
     */
    private void initTableTask() {
        initColumnTaskId();
        initColumnTaskName();
        initColumnTaskTime();
        initColumnTaskRecurring();
        setTableTaskRowStyle();
        tableTask.setItems(taskList);
    }
    
    /**
     * Initialize tableEvent.
     * This method initialize tableEvent by indicating what field to be
     * put inside each cell.
     */
    private void initTableEvent() {
        initColumnEventId();
        initColumnEventName();
        initColumnEventStartTime();
        initColumnEventEndTime();
        initColumnEventRecurring();
        setTableEventRowStyle();
        tableEvent.setItems(eventList);
    }
    
    /**
     * Detect the key that are being released when the user is typing in textInput.
     */
    private void initTextInputKeyDetection() {
        textInput.setOnKeyReleased(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                processKeyCode(event);
            }
        });
    }
    
    /**
     * Set the focus on the textInput component of the UI with the caret.
     */
    private void focusTextInput() {
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                textInput.requestFocus();
            }
        });
    }
    
    /**
     * Initialize the columnTaskId of the tableTask with the parameter from LogicTask object.
     */
    private void initColumnTaskId() {
        columnTaskId
                .setCellValueFactory(param -> new ReadOnlyStringWrapper(Integer.toString(param.getValue().getId())));
    }
    
    /**
     * Initialize the columnTaskName of the tableTask with the parameter from LogicTask object.
     */
    private void initColumnTaskName() {
        columnTaskName.setCellValueFactory(param -> new ReadOnlyStringWrapper(param.getValue().getName()));
    }
    
    /**
     * Initialize the columnTaskTime of the tableTask with the parameter from LogicTask object.
     */
    private void initColumnTaskTime() {
        columnTaskTime.setCellValueFactory(
                new Callback<TableColumn.CellDataFeatures<LogicTask, String>, ObservableValue<String>>() {
                    @Override
                    public ObservableValue<String> call(CellDataFeatures<LogicTask, String> param) {
                        return parseDeadlineFromLogicTask(param);
                    }
                });
    }
    
    /**
     * Initialize the columnTaskRecurring of the tableTask with the parameter from LogicTask object.
     */
    private void initColumnTaskRecurring() {
        columnTaskRecurring.setCellValueFactory(
                new Callback<TableColumn.CellDataFeatures<LogicTask, String>, ObservableValue<String>>() {
                    @Override
                    public ObservableValue<String> call(CellDataFeatures<LogicTask, String> param) {
                        return parsePeriodFromLogicTask(param);
                    }
                });
    }
    
    /**
     * Set the each individual row of the tableTask with an additional specific style.
     * This is done through the creation of new private class called TableTaskRowWithStyles.
     * There are three additional styles:
     * 1. strike-through text for the row with a task that is done.
     * 2. red background for the row with a task that is overdue (passed its deadline).
     * 3. green background for the row with a task that is newly created.
     */
    private void setTableTaskRowStyle() {
        tableTask.setRowFactory(new Callback<TableView<LogicTask>, TableRow<LogicTask>>() {
            @Override
            public TableRow<LogicTask> call(TableView<LogicTask> tableEventView) {
                
                return new TableTaskRowWithStyles();
            }
        });
    }
    
    /**
     * Initialize the columnEventId of the tableEvent with the parameter from LogicEvent object.
     */
    private void initColumnEventId() {
        columnEventId
                .setCellValueFactory(param -> new ReadOnlyStringWrapper(Integer.toString(param.getValue().getId())));
    }

    /**
     * Initialize the columnEventName of the tableEvent with the parameter from LogicEvent object.
     */
    private void initColumnEventName() {
        columnEventName.setCellValueFactory(param -> new ReadOnlyStringWrapper(param.getValue().getName()));
    }

    /**
     * Initialize the columnEventStartTime of the tableEvent with the parameter from LogicEvent object.
     */
    private void initColumnEventStartTime() {
        columnEventStartTime.setCellValueFactory(
                param -> new ReadOnlyStringWrapper(convertDateTimeToString(param.getValue().getStart())));
    }
    
    /**
     * Initialize the columnEventEndTime of the tableEvent with the parameter from LogicEvent object.
     */
    private void initColumnEventEndTime() {
        columnEventEndTime.setCellValueFactory(
                param -> new ReadOnlyStringWrapper(convertDateTimeToString(param.getValue().getEnd())));
    }
    
    /**
     * Initialize the columnEventRecurring of the tableEvent with the parameter from LogicEvent object.
     */
    private void initColumnEventRecurring() {
        columnEventRecurring.setCellValueFactory(
                new Callback<TableColumn.CellDataFeatures<LogicEvent, String>, ObservableValue<String>>() {
                    @Override
                    public ObservableValue<String> call(CellDataFeatures<LogicEvent, String> param) {
                        return parsePeriodFromLogicEvent(param);
                    }
                });
    }

    /**
     * Set the each individual row of the tableEvent with an additional specific style.
     * This is done through the creation of new private class called TableEventRowWithStyles.
     * There are three additional styles:
     * 1. strike-through text for the row with a task that is done.
     * 2. red background for the row with a task that is overdue (passed its deadline).
     * 3. green background for the row with a task that is newly created.
     */
    private void setTableEventRowStyle() {
        tableEvent.setRowFactory(new Callback<TableView<LogicEvent>, TableRow<LogicEvent>>() {
            @Override
            public TableRow<LogicEvent> call(TableView<LogicEvent> tableEventView) {
                return new TableEventRowWithStyles();
            }
        });
    }
    /**
     * Add the new user input into inputHistory array.
     * If the new input is the same as the previous input, the new input will not
     * be added to the inputHistory array.
     * 
     * @param userInput User input from textInput.
     */
    private void addInputToHistory(String userInput) {
        if(!inputHistory.isEmpty()){ 
            checkForRepeatedInput(userInput);
        } else {
            storeInputToHistory(userInput);
        }

    }

    /**
     * Only add the input if it is not repeated. Else, reset the inputHistoryIndex.
     * 
     * @param userInput User input from textInput.
     */
    private void checkForRepeatedInput(String userInput) {
        if (!isRepeatedInput(userInput)) {
            storeInputToHistory(userInput);
        } else {
            inputHistoryIndex = inputHistory.size();
        }
    }
    
    /**
     * Check if the new userInput is the same as the last input from inputHistory array.
     * 
     * @param userInput User input from textInput.
     * @return          true if the user input is same as the last input.
     */
    private boolean isRepeatedInput(String userInput) {
        String prevInput = inputHistory.get(inputHistory.size() - 1); 
        boolean isRepeated = prevInput.equals(userInput);
        return isRepeated;
    }
    
    /**
     * Store the new user input inside inputHistory and update inputHistory index.
     * 
     * @param userInput User input from textInput.
     */
    private void storeInputToHistory(String userInput) {
        inputHistory.add(userInput);
        inputHistoryIndex = inputHistory.size();
    }

    /**
     * Execute the user input using the Logic object.
     * 
     * @param userInput User input from textInput.
     */
    private void process(String userInput) {
        ExecuteResult result = l.executeCommand(userInput);
        ExecuteResult.CommandType commnadType = result.getType();
        String comment = result.getComment();
        processCommandType(result, commnadType, comment);
    }

    /**
     * Process how the UI should react to the user input depending on the command given.
     * 
     * @param result            The result after execution.
     * @param commnadType       The type of the command of the result.
     * @param comment           The comment of the result.
     */
    private void processCommandType(ExecuteResult result, ExecuteResult.CommandType commnadType, String comment) {
        switch (commnadType) {
        case HELP :
            showWebView();
            break;
        case EXIT :
            processExit();
            break;
        case DISPLAY :
            hideWebView();
            labelFeedback.setText(comment);
            populateList(result);
            break;
        default :
            hideWebView();
            labelFeedback.setText(comment);
            break;
        }
    }

    /**
     * Exit the program when exit command is called.
     * A log is created before the platform exits.
     */
    private void processExit() {
        STORE_LOG.log(Level.INFO, LOG_SHUTDOWN);
        Platform.exit();
    }

    /**
     * Hide the webView.
     */
    private void hideWebView() {
        webView.setVisible(false);
        webView.toBack();
        tableEvent.setVisible(true);
        tableTask.setVisible(true);
    }

    /**
     * Make the webView visible to the user when help command is called.
     */
    private void showWebView() {
        webView.setVisible(true);
        webView.toFront();
        tableEvent.setVisible(false);
        tableTask.setVisible(false);
    }

    /**
     * Process when UP key and DOWN key is released when user is typing in the textInput.
     * 
     * @param event KeyEvent when Key is released.
     */
    private void processKeyCode(KeyEvent event) {
        KeyCode keyCode = event.getCode();
        switch (keyCode) {
        case UP :
            processUpKey();
            break;
        case DOWN :
            processDownKey();
            break;
        default :
            break;
        }
    }

    /**
     * Cycle through the previous element of inputHistory array when UP key is released.
     * The element will be shown on the inputText field.
     */
    private void processUpKey() {
        if (inputHistoryIndex > 0) {
            inputHistoryIndex--;
            setTextInputHistory();
            setEndCaretPosition();
        }
    }

    /**
     * Cycle through the subsequent element of inputHistory array when DOWN key is released.
     * The element will be shown on the inputText field.
     */
    private void processDownKey() {
        if (inputHistoryIndex < inputHistory.size() - 1) {
            inputHistoryIndex++;
            setTextInputHistory();
            setEndCaretPosition();
        } else if (inputHistoryIndex == inputHistory.size() - 1) {
            inputHistoryIndex++;
            textInput.setText(FIELD_EMPTY);
        }
    }

    /**
     * Set the position of the caret to be at the end of the input text.
     */
    private void setEndCaretPosition() {
        textInput.positionCaret(textInput.getText().length());
    }

    /**
     * Set the text of the inputText with a string from inputHistory.
     */
    private void setTextInputHistory() {
        textInput.setText(inputHistory.get(inputHistoryIndex));
    }

    /**
     * Return the recurring period of an event in a String format.
     * The recurring period can have no limit, limit with a specific date, and limit with
     * number of times to be repeated. The period can be in day(s) or month(s).
     * 
     * @param param     Cell of the columnEventRecurring from tableEvent.
     * @return          Period in String format.       
     */
    private ObservableValue<String> parsePeriodFromLogicEvent(CellDataFeatures<LogicEvent, String> param) {
        LocalDate limitDate = param.getValue().getLimitDate();
        int limitOccur = param.getValue().getLimitOccur();
        String periodString = convertTemporalToString(param.getValue().getPeriod());
        periodString += parseLimit(limitDate, limitOccur);
        
        return new ReadOnlyStringWrapper(periodString);
    }

    /**
     * Return the recurring period of a task in a String format.
     * The recurring period can have no limit, limit with a specific date, and limit with
     * number of times to be repeated. The period can be in day(s) or month(s).
     * 
     * @param param     Cell of the columnTaskRecurring from tableTask.
     * @return          Period in String format.       
     */
    private ObservableValue<String> parsePeriodFromLogicTask(CellDataFeatures<LogicTask, String> param) {
        LocalDate limitDate = param.getValue().getLimitDate();
        int limitOccur = param.getValue().getLimitOccur();
        String periodString = convertTemporalToString(param.getValue().getPeriod());
        periodString += parseLimit(limitDate, limitOccur);
        
        return new ReadOnlyStringWrapper(periodString);
    }

    /**
     * Return the date limit or the number of times to be repeated for recurring task/event in String format.
     * What to be returned depends on what is available.
     * 
     * @param limitDate         Limit date of a recurring task/event.
     * @param limitOccur        Number of times to be repeated for a recurring task/event.
     * @return                  Limit in String format.
     */
    private String parseLimit(LocalDate limitDate, int limitOccur) {
        String limit = FIELD_EMPTY;
        if (limitOccur > 0) {
            limit = parseLimitOccur(limitOccur);
        } else if (limitDate != null) {
            limit = parseLimitDate(limitDate);
        }
        
        return limit;
    }

    /**
     * Return the date limit of a recurring task/event in String format.
     * 
     * @param limitDate Limit date of a recurring task/event.
     * @return          Limit date in String format.
     */
    private String parseLimitDate(LocalDate limitDate) {
        String parse = FIELD_LIMIT_DATE + convertDateToString(limitDate);
        
        return parse;
    }

    /**
     * Return the repeated limited (number of times) of a recurring task/event in String format.
     * This will be parse in the form of "for 4 time(s)" where 4 is the value of limitOccur.
     * 
     * @param limitOccur        Number of times for a recurring task/event to be repeated.
     * @return                  Limit in String format.
     */
    private String parseLimitOccur(int limitOccur) {
        String parse = FIELD_LIMIT_OCCUR_PREFIX + limitOccur + FIELD_LIMIT_OCCUR_SUFFIX;
        
        return parse;
    }

    /**
     * Return a date in String format.
     * 
     * @param limitDate LocalDate object.
     * @return          Date in String format.
     */
    private String convertDateToString(LocalDate limitDate) {
        String dateString = limitDate.format(DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM));
        
        return dateString;
    }

    /**
     * Return the deadline of a task in String format.
     * 
     * @param param     Cell of the columnTaskTime from tableTask.
     * @return          Deadline of a task in String format.
     */
    private ObservableValue<String> parseDeadlineFromLogicTask(CellDataFeatures<LogicTask, String> param) {
        LocalDateTime deadline = param.getValue().getDeadline();
        String deadlineString = convertDeadlineToString(deadline);
        
        return new ReadOnlyStringWrapper(deadlineString);
    }

    /**
     * Return a deadline in String format.
     * If there is no deadline, return an empty String.
     * 
     * @param deadline  Deadline of a task.
     * @return          Deadline in String format.
     */
    private String convertDeadlineToString(LocalDateTime deadline) {
        String deadlineString;
        if (deadline != null) {
            deadlineString = convertDateTimeToString(deadline);
        } else {
            deadlineString = FIELD_EMPTY;
        }
        
        return deadlineString;
    }

    /**
     * Return a LocalDateTime object in String format.
     * 
     * @param deadline  LocalDateTime object.
     * @return          LocalDateTime in String format.
     */
    private String convertDateTimeToString(LocalDateTime deadline) {
        String dateTimeString = deadline.format(DateTimeFormatter.ofLocalizedDateTime(FormatStyle.MEDIUM));
        
        return dateTimeString;
    }

    /**
     * Return a TemporalAmoun object in String format.
     * If the object is null, return empty String.
     * 
     * @param period    TemporalAmout object.
     * @return          TemporalAmoun in String format.
     */
    private String convertTemporalToString(TemporalAmount period) {
        String periodString;
        if (period == null) {
            periodString = FIELD_EMPTY;
        } else if (period instanceof Period) {
            periodString = convertPeriodToString(((Period) period).normalized());
        } else {
            periodString = convertDurationToString((Duration) period);
        }
        
        return periodString;
    }

    /**
     * Return a parsed Period object in String format.
     * The period can be parsed with day(s), month(s), or year(s) depending on the type of period.
     * 
     * @param period    Period object.
     * @return          Parsed Period in String format.
     */
    private String convertPeriodToString(Period period) {
        int years = period.getYears();
        int months = period.getMonths();
        int days = period.getDays();
        String periodString = formatDuration(years, FIELD_YEAR) + formatDuration(months, FIELD_MONTH)
                + formatDuration(days, FIELD_DAY);

        return periodString;
    }

    /**
     * Return a parsed Duration object in String format.
     * 
     * @param duration  Duration object.        
     * @return          Parsed Duration in String format.
     */
    private String convertDurationToString(Duration duration) {
        long hours = duration.toHours();
        long minutes = duration.toMinutes() % 60;
        String durationString = formatDuration(hours, FIELD_HOUR) + formatDuration(minutes, FIELD_MINUTE);
        
        return durationString;
    }

    /**
     * Return a parsed Duration object in String format with a specific label.
     * The label can be hour(s) or minute(s).
     * 
     * @param duration  Duration object.        
     * @return          Parsed Duration in String format.
     */
    private String formatDuration(long duration, String label) {
        return duration == 0 ? FIELD_EMPTY : duration + " " + label + " ";
    }

    /**
     * Populate the tableTask and tableEvent with the result after the execution.
     * 
     * @param result    ExcuteResult object obtained after execution.
     */
    public void populateList(ExecuteResult result) {
        populateTaskList(result);
        populateEventList(result);
    }

    /**
     * Populate the tableEvent with the eventList obtained from the result after execution.
     * 
     * @param result    ExcuteResult object obtained after execution.
     */
    private void populateEventList(ExecuteResult result) {
        eventList.clear();
        for (LogicEvent event : result.getEventList()) {
            eventList.add(event);
        }
    }

    /**
     * Populate the tableTask with the taskList obtained from the result after execution.
     * 
     * @param result    ExcuteResult object obtained after execution.
     */
    private void populateTaskList(ExecuteResult result) {
        taskList.clear();
        for (LogicTask task : result.getTaskList()) {
            taskList.add(task);
        }
    }

    /**
     * This class is used to create a TableRow<LogicEvent> with an additional specific styles for each row.
     * There are three additional styles:
     * 1. strike-through text for the row with a task that is done.
     * 2. red background for the row with a task that is overdue (passed its deadline).
     * 3. green background for the row with a task that is newly created.
     */
    private class TableEventRowWithStyles extends TableRow<LogicEvent> {
        @Override
        protected void updateItem(LogicEvent event, boolean b) {
            super.updateItem(event, b);
            boolean overdue = (event != null) && (event.getOverdue());
            boolean newEvent = (event != null) && (event.isNew());
            boolean done = (event != null) && (!event.isDone());
            setOverdueStyle(overdue, newEvent, done);
            setDoneStyle(event, b, done);
            setNewStyle(event, b, newEvent);
        }

        private void setNewStyle(LogicEvent event, boolean b, boolean newEvent) {
            super.updateItem(event, b);
            pseudoClassStateChanged(PSEUDO_CLASS_NEW, newEvent);
        }

        private void setDoneStyle(LogicEvent event, boolean b, boolean done) {
            super.updateItem(event, b);
            pseudoClassStateChanged(PSEUDO_CLASS_DONE, done);
        }

        private void setOverdueStyle(boolean overdue, boolean newEvent, boolean done) {
            if (!done && !newEvent) {
                pseudoClassStateChanged(PSEUDO_CLASS_OVERDUE, overdue);
            }
        }
    }

    /**
     * This class is used to create a TableRow<LogicTask> with an additional specific styles for each row.
     * There are three additional styles:
     * 1. strike-through text for the row with a task that is done.
     * 2. red background for the row with a task that is overdue (passed its deadline).
     * 3. green background for the row with a task that is newly created.
     */
    private class TableTaskRowWithStyles extends TableRow<LogicTask> {
        @Override
        protected void updateItem(LogicTask task, boolean b) {
            super.updateItem(task, b);
            boolean overdue = (task != null) && (task.getOverdue());
            boolean newTask = (task != null) && (task.isNew());
            boolean done = (task != null) && (!task.isDone());
            setOverdueStyle(overdue, newTask, done);
            setDoneStyle(task, b, done);
            setNewStyle(task, b, newTask);
        }
        
        private void setNewStyle(LogicTask event, boolean b, boolean newEvent) {
            super.updateItem(event, b);
            pseudoClassStateChanged(PSEUDO_CLASS_NEW, newEvent);
        }

        private void setDoneStyle(LogicTask task, boolean b, boolean done) {
            super.updateItem(task, b);
            pseudoClassStateChanged(PSEUDO_CLASS_DONE, done);
        }

        private void setOverdueStyle(boolean overdue, boolean newTask, boolean done) {
            if (!done && !newTask) {
                pseudoClassStateChanged(PSEUDO_CLASS_OVERDUE, overdue);
            }
        }
    }

}
```
###### /src/lifetracker/LifeTracker.java
``` java
public class LifeTracker extends Application {

    private static final String LOG_FOLDER = "logs/";
    private static final String LOG_FILE = "lifetracker.log";
    private Storage fileStorage;

    public static void main(String args[]) throws Exception {
        setLogger();
        launch(args);
    }

```
###### /src/lifetracker/LifeTracker.java
``` java
    @Override
    public void start(Stage primaryStage) throws Exception {
        fileStorage = new ThreadedFileStorage();
        FXMLLoader fxmlLoader = new FXMLLoader();
        Parent root = fxmlLoader.load(getClass().getResource("/lifetracker/ui/UiDesign.fxml").openStream());
        Scene scene = new Scene(root);
        scene.getStylesheets().add(getClass().getResource("/lifetracker/ui/application.css").toExternalForm());   
        primaryStage.setTitle("Life Tracker");
        primaryStage.setScene(scene);
        Parser commandParser = new ParserImpl(new CommandFactoryImpl());
        Logic programLogic = new LogicImpl(commandParser, fileStorage);
        UiController uiController = fxmlLoader.getController();
        uiController.setLogic(programLogic);
        uiController.populateList(programLogic.executeCommand("today"));
        primaryStage.getIcons().add(new Image("/lifetracker/icon.png"));
        primaryStage.show();
        
    }
    
    @Override
    public void stop() throws Exception{
        fileStorage.close();
    }
}
```
###### /test/lifetracker/command/DeleteCommandTest.java
``` java
public class DeleteCommandTest {
    
    @Test
    public void testUnexecutedComment() throws Exception {
        DeleteCommand deleteCommand = new DeleteCommand(1);
        Assert.assertEquals(deleteCommand.getComment(), CommandObject.MESSAGE_ERROR);
    }
    
    @Test
    public void testExecute() throws Exception {

        CalendarListImpl mockedCalendar = new CalendarListImpl();
        
        mockedCalendar.add("task");
        
        DeleteCommand deleteCommand = new DeleteCommand(1);
        deleteCommand.execute(mockedCalendar);
        
        Assert.assertEquals("1 is deleted.", deleteCommand.getComment());
        
    }
    
    @Test(expected = IllegalArgumentException.class)
    public void testFailExecute() throws IllegalArgumentException {

        CalendarListImpl mockedCalendar = new CalendarListImpl();       
        DeleteCommand deleteCommand = new DeleteCommand(1);
        deleteCommand.execute(mockedCalendar);

    }
    
    
}
```
###### /test/lifetracker/integration/IntegrationLogicTest.java
``` java
        //Partition: Add events with missing end date parameters
        actual = logic.executeCommand("dinner from 23/3/16 2.30pm");
        LocalDateTime expectedStartDateTime2 = LocalDateTime.of(2016, 3, 23, 14, 30);
        LocalDateTime expectedEndDateTime2 = LocalDateTime.of(2016, 3, 23, 15, 30);
        expected.addEventLine(1, "interview", expectedStartDateTime1, expectedEndDateTime1, false, true, null, -1, null,
                false);
        expected.addEventLine(2, "dinner", expectedStartDateTime2, expectedEndDateTime2, false, true, null, -1, null,
                false);
        expected.setComment(String.format(MESSAGE_ADD, "dinner"));
        assertExecuteResult(expected, actual);
        actual = logic.executeCommand("chalet from 23/3/16 2.30pm to 24/3/16");
        LocalDateTime expectedStartDateTime3 = LocalDateTime.of(2016, 3, 23, 14, 30);
        LocalDateTime expectedEndDateTime3 = LocalDateTime.of(2016, 3, 24, 14, 30);
        expected.addEventLine(1, "interview", expectedStartDateTime1, expectedEndDateTime1, false, true, null, -1, null,
                false);
        expected.addEventLine(2, "dinner", expectedStartDateTime2, expectedEndDateTime2, false, true, null, -1, null,
                false);
        expected.addEventLine(3, "chalet", expectedStartDateTime3, expectedEndDateTime3, false, true, null, -1, null,
                false);
        expected.setComment(String.format(MESSAGE_ADD, "chalet"));
        assertExecuteResult(expected, actual);
        actual = logic.executeCommand("class from 23/3/16 2.30pm to 7pm");
        LocalDateTime expectedStartDateTime4 = LocalDateTime.of(2016, 3, 23, 14, 30);
        LocalDateTime expectedEndDateTime4 = LocalDateTime.of(2016, 3, 23, 19, 0);
        expected.addEventLine(1, "interview", expectedStartDateTime1, expectedEndDateTime1, false, true, null, -1, null,
                false);
        expected.addEventLine(2, "dinner", expectedStartDateTime2, expectedEndDateTime2, false, true, null, -1, null,
                false);
        expected.addEventLine(3, "chalet", expectedStartDateTime3, expectedEndDateTime3, false, true, null, -1, null,
                false);
        expected.addEventLine(4, "class", expectedStartDateTime4, expectedEndDateTime4, false, true, null, -1, null,
                false);
        expected.setComment(String.format(MESSAGE_ADD, "class"));
        assertExecuteResult(expected, actual);
        
        //Partion: Add events with missing start parameters
        actual = logic.executeCommand("swim from 23/3/16 to 7pm");
        LocalDateTime expectedStartDateTime5 = LocalDateTime.of(2016, 3, 23, 18, 00);
        LocalDateTime expectedEndDateTime5 = LocalDateTime.of(2016, 3, 23, 19, 0);
        expected.addEventLine(1, "interview", expectedStartDateTime1, expectedEndDateTime1, false, true, null, -1, null,
                false);
        expected.addEventLine(2, "dinner", expectedStartDateTime2, expectedEndDateTime2, false, true, null, -1, null,
                false);
        expected.addEventLine(3, "chalet", expectedStartDateTime3, expectedEndDateTime3, false, true, null, -1, null,
                false);
        expected.addEventLine(4, "class", expectedStartDateTime4, expectedEndDateTime4, false, true, null, -1, null,
                false);
        expected.addEventLine(5, "swim", expectedStartDateTime5, expectedEndDateTime5, false, true, null, -1, null,
                false);
        expected.setComment(String.format(MESSAGE_ADD, "swim"));
        assertExecuteResult(expected, actual);
        
    }

```
###### /test/lifetracker/integration/IntegrationLogicTest.java
``` java
        //Partition: Add recurring events with limitOccur
        actual = logic.executeCommand("add lesson from 24/3/16 3pm to 4pm every week for 5");
        LocalDateTime expectedStartDateTime2 = LocalDateTime.of(2016, 3, 24, 15, 0);
        LocalDateTime expectedEndDateTime2 = expectedStartDateTime2.plusHours(1);
        Period expectedRecurringPeriod2 = Period.ofWeeks(1);
        while (expectedEndDateTime2.isBefore(LocalDateTime.now())) {
            expectedStartDateTime2 = expectedStartDateTime2.plus(expectedRecurringPeriod2);
            expectedEndDateTime2 = expectedEndDateTime2.plus(expectedRecurringPeriod2);
        }
        expected.addEventLine(1, "tutorial", expectedStartDateTime2, expectedEndDateTime1, false, true,
                expectedRecurringPeriod1, 0, null, false);
        expected.addEventLine(2, "lesson", expectedStartDateTime2, expectedEndDateTime1, false, true,
                expectedRecurringPeriod1, 5, null, false);
        expected.setComment(String.format(MESSAGE_ADD, "lesson"));
        assertExecuteResult(expected, actual);
        
        //Partition: Add recurring events with limit date
        actual = logic.executeCommand("add work from 24/3/16 3pm to 4pm every week until 25/3/16");
        LocalDateTime expectedStartDateTime3 = LocalDateTime.of(2016, 3, 24, 15, 0);
        LocalDateTime expectedEndDateTime3 = expectedStartDateTime3.plusHours(1);
        LocalDate limitDate = LocalDate.of(2016, 3, 25);
        Period expectedRecurringPeriod3 = Period.ofWeeks(1);
        while (expectedEndDateTime3.isBefore(LocalDateTime.now())) {
            expectedStartDateTime3 = expectedStartDateTime3.plus(expectedRecurringPeriod3);
            expectedEndDateTime3 = expectedEndDateTime3.plus(expectedRecurringPeriod3);
        }
        expected.addEventLine(1, "tutorial", expectedStartDateTime1, expectedEndDateTime2, false, true,
                expectedRecurringPeriod1, 0, null, false);
        expected.addEventLine(2, "lesson", expectedStartDateTime2, expectedEndDateTime2, false, true,
                expectedRecurringPeriod1, 5, null, false);
        expected.addEventLine(2, "work", expectedStartDateTime2, expectedEndDateTime2, false, true,
                expectedRecurringPeriod1, 0, limitDate, false);
        expected.setComment(String.format(MESSAGE_ADD, "work"));
        assertExecuteResult(expected, actual);
    }

```
###### /bin/lifetracker/ui/README.css
``` css
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px;
  color: #333;
}
```
###### /bin/lifetracker/ui/application.css
``` css
@font-face {
	src: url('/lifetracker/ui/Lato-Regular.ttf');
}

.root {
	-fx-font-family: "Lato-Regular";
}

#labelTitle {
	-fx-background-color: #4B77BE;
	-fx-border-radius: 5 5 5 5;
    -fx-background-radius: 5 5 5 5;
    -fx-text-fill: white;
}

#textInput {
	-fx-prompt-text-fill: derive(-fx-control-inner-background,-30.0%);
}

.table-column {
	-fx-alignment: CENTER;
}

#columnTaskName, #columnEventName {
	-fx-alignment: CENTER-LEFT;
	-fx-padding: 0 0 0 15;
}

.table-view .placeholder .label {
	-fx-font-family: 'Lato-Bold'; 
    -fx-font-size: 20px;  
}

.table-view .column-header .label { 
	-fx-font-family: 'Lato-Bold'; 
    -fx-font-size: 16px;  
    -fx-font-weight: bold;      
    -fx-text-fill: white;  
    -fx-alignment: center-left;   
    -fx-padding: 5.0 5.0 5.0 5.0;  
    -fx-alignment: CENTER;
}  

.table-view .column-header {
	-fx-background-color: #89C4F4;
	-fx-border-radius: 5 5 0 0;
    -fx-background-radius: 5 5 0 0;
    -fx-pref-height: 45.0px;
} 

.table-view .filler{  
    -fx-background-radius: 0.0 5.0 0.0 0.0;    
    -fx-background-color: #89C4F4;      
    -fx-size: 45.0px;  
    -fx-min-height: 45.0px;      
}  

.table-view .placeholder{  
     -fx-background-color: white;      
}  

.table-view {
	-fx-background-color: transparent;
	-fx-border-color: black;
	-fx-border-width: 0.5px;
	-fx-border-radius: 5 5 5 5;
    -fx-background-radius: 5 5 5 5; 
}

.table-view .column-header-background {  
    -fx-background-radius: 5.0 5.0 0.0 0.0;  
    -fx-background-color: #89C4F4;  
} 

/* EACH ROW */
.table-row-cell {      
    -fx-border-width: 0;     
    -fx-pref-height: 45.0px;  
    -fx-font-size: 14px; 
    -fx-background-radius: 5 5 5 5; 
    -fx-border-radius: 5 5 5 5;
}  

.table-row-cell .table-column{  
    -fx-border-width: 1px;          
}  

.table-row-cell:overdue {
 	-fx-background-color: rgba(255, 159, 160, .4);
}

.table-row-cell:new {
 	-fx-background-color: rgba(0, 255, 0, .4);
}

.table-row-cell:done .text {
 	-fx-strikethrough: true;
}
  

/* HIDE HORIZONTAL SCROLLBAR */
.table-view .scroll-bar:horizontal .increment-button,
.table-view .scroll-bar:horizontal .decrement-button {
    -fx-background-color: null;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-padding: 0;
}

.table-view .scroll-bar:horizontal .increment-arrow, 
.table-view .scroll-bar:horizontal .decrement-arrow {
    -fx-background-color: null;
    -fx-background-radius: 0;
    -fx-background-insets: 0;
    -fx-padding: 0;
    -fx-shape: null;
}

/*
#columnTaskID, #columnEventID {
	-fx-border-radius: 10 0 0 0;
    -fx-background-radius: 10 0 0 0;
}

#columnTaskRecurring, #columnEventRecurring {
	-fx-border-radius: 0 10 0 0;
    -fx-background-radius: 0 10 0 0;
}*/
```
###### /bin/lifetracker/ui/UiDesign.fxml
``` fxml

<AnchorPane xmlns="http://javafx.com/javafx/8.0.65" xmlns:fx="http://javafx.com/fxml/1" fx:controller="lifetracker.ui.UiController">
   <children>
      <VBox alignment="TOP_CENTER" maxHeight="-Infinity" maxWidth="-Infinity" minHeight="-Infinity" minWidth="-Infinity" spacing="2.5" style="-fx-background-color: transparent;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
         <children>
            <AnchorPane VBox.vgrow="NEVER">
               <children>
                  <Label fx:id="labelTitle" alignment="CENTER" contentDisplay="CENTER" text="LIFE TRACKER" textAlignment="CENTER" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <font>
                        <Font name="Lato Bold" size="36.0" />
                     </font>
                  </Label>
               </children>
            </AnchorPane>
            <AnchorPane maxHeight="1.7976931348623157E308" VBox.vgrow="ALWAYS">
               <children>
                  <StackPane maxHeight="1.7976931348623157E308" style="-fx-background-color: transparent;" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <children>
                        <WebView fx:id="webView" prefHeight="-1.0" prefWidth="-1.0" />
                        <VBox alignment="TOP_CENTER" spacing="10.0" style="-fx-background-color: transparent;" StackPane.alignment="TOP_CENTER">
                           <children>
                              <TableView fx:id="tableEvent" prefHeight="225.0" VBox.vgrow="ALWAYS">
                                <placeholder>
        					    	<Label text="No event taking place today:)"/>
    							</placeholder>
                                <columns>
                                    <TableColumn fx:id="columnEventStartTime" editable="false" maxWidth="200.0" minWidth="2.0" prefWidth="200.0" resizable="false" sortable="false" text="START TIME" />
                                    <TableColumn fx:id="columnEventEndTime" editable="false" maxWidth="200.0" minWidth="2.0" prefWidth="200.0" resizable="false" sortable="false" text="END TIME" />
                                  <TableColumn fx:id="columnEventName" editable="false" minWidth="0.0" prefWidth="340.0" resizable="false" sortable="false" text="EVENT" />
                                  <TableColumn fx:id="columnEventId" editable="false" maxWidth="60.0" prefWidth="60.0" resizable="false" sortable="false" text="#ID" />
                                    <TableColumn fx:id="columnEventRecurring" editable="false" maxWidth="250.0" minWidth="0.0" prefWidth="265.0" resizable="false" sortable="false" text="EVERY" />
                                </columns>
                              </TableView>
                              <TableView fx:id="tableTask" prefHeight="225.0" VBox.vgrow="ALWAYS">
                                 <placeholder>
        					     	<Label text="No task due today:)"/>
    							 </placeholder>
                                 <columns>
                                    <TableColumn fx:id="columnTaskTime" editable="false" maxWidth="400.0" minWidth="2.0" prefWidth="400.0" resizable="false" sortable="false" text="TIME" />
                                    <TableColumn fx:id="columnTaskName" editable="false" maxWidth="340.0" prefWidth="340.0" resizable="false" sortable="false" text="TASK" />
                                    <TableColumn fx:id="columnTaskId" editable="false" maxWidth="60.0" prefWidth="60.0" resizable="false" sortable="false" text="#ID" />
                                    <TableColumn fx:id="columnTaskRecurring" editable="false" maxWidth="250.0" minWidth="2.0" prefWidth="265.0" resizable="false" sortable="false" text="EVERY" />
                                 </columns>
                              </TableView>
                           </children>
                        </VBox>
                     </children>
                  </StackPane>
               </children>
            </AnchorPane>
            <AnchorPane maxHeight="-Infinity" VBox.vgrow="NEVER">
               <children>
                  <Label fx:id="labelFeedback" alignment="CENTER" contentDisplay="CENTER" prefHeight="80.0" prefWidth="923.0" text="Welcome to the Life Tracker, Spend less time planning so you always know what's next." textAlignment="CENTER" wrapText="true" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0">
                     <font>
                        <Font name="Lato Regular" size="24.0" />
                     </font>
                  </Label>
               </children>
            </AnchorPane>
            <AnchorPane maxHeight="-Infinity" VBox.vgrow="NEVER">
               <children>
                  <TextField fx:id="textInput" alignment="CENTER" onAction="#getInput" prefHeight="0.0" promptText="Enter Command" AnchorPane.bottomAnchor="0.0" AnchorPane.leftAnchor="0.0" AnchorPane.rightAnchor="0.0" AnchorPane.topAnchor="0.0">
                     <font>
                        <Font name="Lato Light" size="24.0" />
                     </font>
                  </TextField>
               </children>
            </AnchorPane>
         </children>
         <padding>
            <Insets bottom="10.0" left="10.0" right="10.0" top="10.0" />
         </padding>
      </VBox>
   </children>
</AnchorPane>
```
