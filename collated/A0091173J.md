# A0091173J
###### /src/lifetracker/storage/Storage.java
``` java

/**
 * A storage mechanism for storing calendars.
 */
public interface Storage extends AutoCloseable {

    /**
     * Sets the storage destination, for example, the filename, and initializes the storage.
     *
     * @param destination The destination string.
     */
    void setStoreAndStart(String destination) throws IOException;

    /**
     * Stores the String.
     *
     * @param storeString The String to store.
     * @throws IOException If there was an error storage to the storage medium.
     */
    void store(String storeString) throws IOException;

    /**
     * Loads the data from the storage file and returns it directly as a String.
     *
     * @return The content of the file.
     * @throws IOException If there was an error reading the data file.
     */
    String load() throws IOException;
}
```
###### /src/lifetracker/storage/ThreadedFileStorage.java
``` java

/**
 * A File storage, that runs the file write on a separate thread.
 * <p>
 * This class works by accepting asynchronous request to store data to a file. It then passes the data to a separate
 * thread so it can be stored concurrently. If multiple sets of data are submitted before the first set is written to
 * file, then only the latest set of data will be written.
 */
public class ThreadedFileStorage implements Storage {

    private static final String DEFAULT_FILENAME = "lifetracker.dat";

    private static final String ERROR_FILE_IS_DIRECTORY = "Filename provided is actually a directory!";
    private static final String ERROR_INTERRUPTED_CLOSE = "Thread was interrupted while finishing up requests!";

    private File storageFile;
    private Thread fileStoreThread;
    private FileStoreProcess fileStoreProcess;

    /**
     * Creates a new {@code ThreadedFileStorage} that stores the data in "lifetracker.dat".
     *
     * @throws IOException If there was an accessing the file.
     */
    public ThreadedFileStorage() throws IOException {
        this(DEFAULT_FILENAME);
    }

    /**
     * Creates a new {@code ThreadedFileStorage} that stores the data in the file specified by the file name.
     *
     * @param fileName The file name of the storage file.
     * @throws IOException If there was an error accessing the file.
     */
    public ThreadedFileStorage(String fileName) throws IOException {
        storageFile = prepareFile(fileName);
        startThread(storageFile);
    }

    /**
     * Closes the current running write thread safely, then starts a new thread that writes to the file as specified by
     * filename.
     *
     * @param destination The new file to write to.
     * @throws IOException If there was an error accessing the file.
     */
    @Override
    public void setStoreAndStart(String destination) throws IOException {
        try {
            stopThread();
        } catch (InterruptedException e) {
            System.err.println(ERROR_INTERRUPTED_CLOSE);
        }

        storageFile = prepareFile(destination);

        startThread(storageFile);
    }

    /**
     * Stores the data to the file.
     * <p>
     * This method only submits the data to the write thread. Write write will happen concurrently.
     *
     * @param storeString The String to store
     * @throws IOException If there was an error writing to the file
     */
    @Override
    public void store(String storeString) throws IOException {
        assert storeString != null;

        fileStoreProcess.submitSave(storeString);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String load() throws IOException {
        return new String(Files.readAllBytes(storageFile.toPath()), StandardCharsets.UTF_8);
    }

    /**
     * Closes the write thread safely.
     * <p>
     * This method blocks until the write thread finished writing all previous write submissions.
     *
     * @throws Exception If there was an error stopping the write thread.
     */
    @Override
    public void close() throws Exception {
        stopThread();
    }

    private void startThread(File storageFile) throws FileNotFoundException {
        fileStoreProcess = new FileStoreProcess(storageFile);

        fileStoreThread = new Thread(fileStoreProcess);
        fileStoreThread.start();
    }

    private void stopThread() throws InterruptedException {
        fileStoreProcess.submitClose();

        fileStoreThread.join();
    }

    private File prepareFile(String destination) throws IOException {
        File storageFile = new File(destination);

        if (!storageFile.exists()) {
            storageFile.createNewFile();
        } else if (storageFile.isDirectory()) {
            throw new IOException(ERROR_FILE_IS_DIRECTORY);
        }
        return storageFile;
    }

}
```
###### /src/lifetracker/storage/package-info.java
``` java
/**
 * The storage package, which contains the classes for file storage.
 */
package lifetracker.storage;
```
###### /src/lifetracker/calendar/visitor/EntryToEventVisitor.java
``` java

public class EntryToEventVisitor implements EntryVisitor<OldNewEntryPair> {

    private static final String ERROR_EMPTY_START = "Event start date cannot be empty!";
    private static final String ERROR_EMPTY_END = "Event end date cannot be empty!";

    private final String name;
    private final LocalDateTime startDateTime;
    private final LocalDateTime endDateTime;
    private final boolean isForcedConvert;

    public EntryToEventVisitor(String name, LocalDateTime startDateTime, LocalDateTime endDateTime,
            boolean isForcedConvert) {
        this.name = name;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.isForcedConvert = isForcedConvert;
    }

    @Override
    public OldNewEntryPair visit(GenericEntry entry) {
        if (startDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_START);
        }

        if (endDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_END);
        }

        Event event = new Event(entry.getName(), startDateTime, endDateTime);
        event.setId(entry.getId());

        return edit(entry, event);
    }

    @Override
    public OldNewEntryPair visit(DeadlineTask task) {
        if (startDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_START);
        }

        Event event = new Event(task.getName(), startDateTime, task.getDateTime(CalendarProperty.END));
        event.setId(task.getId());
        return edit(task, event);
    }

    @Override
    public OldNewEntryPair visit(RecurringTask task) {
        OldNewEntryPair pair;

        if (isForcedConvert) {
            pair = visit(new DeadlineTask(task));
        } else {
            pair = visit(createRecurringEventFromRecurringTask(task));
        }

        pair.oldEntry = task;
        return pair;
    }

    @Override
    public OldNewEntryPair visit(Event event) {
        Event clone = new Event(event);
        return edit(clone, event);
    }

    @Override
    public OldNewEntryPair visit(RecurringEvent event) {

        if (isForcedConvert) {
            Event newEvent = new Event(event.getName(), event.getDateTime(CalendarProperty.START),
                    event.getDateTime(CalendarProperty.END));
            newEvent.setId(event.getId());
            return edit(event, newEvent);
        } else {
            RecurringEvent clone = new RecurringEvent(event);
            return editCalendarEntry(clone, event);
        }
    }

    private OldNewEntryPair edit(CalendarEntry clone, Event newEvent) {
        Event convertedEvent = newEvent;
        if (isForcedConvert) {
            convertedEvent = new Event(convertedEvent);
        }

        return editCalendarEntry(clone, convertedEvent);
    }

    private OldNewEntryPair editCalendarEntry(CalendarEntry clone, CalendarEntry newEvent) {
        if (name != null && !name.isEmpty()) {
            newEvent.setName(name);
        }

        if (startDateTime != null) {
            newEvent.setDateTime(CalendarProperty.START, startDateTime);
        }

        if (endDateTime != null) {
            newEvent.setDateTime(CalendarProperty.END, endDateTime);
        }

        return new OldNewEntryPair(clone, newEvent);
    }

    private RecurringEvent createRecurringEventFromRecurringTask(RecurringTask task) {
        if (startDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_START);
        }

        RecurringEvent newEvent = new RecurringEvent(task.getName(), startDateTime,
                task.getDateTime(CalendarProperty.END), task.getPeriod());

        newEvent.setId(task.getId());

        if (task.isProperty(CalendarProperty.DATE_LIMITED)) {
            newEvent.setDateTime(CalendarProperty.DATE_LIMIT, task.getDateTime(CalendarProperty.DATE_LIMIT));
        } else if (task.isProperty(CalendarProperty.OCCURRENCE_LIMITED)) {
            newEvent.setOccurrenceLimit(task.getIntegerProperty(CalendarProperty.OCCURRENCE_LIMIT));
        }

        return newEvent;
    }
}
```
###### /src/lifetracker/calendar/visitor/EntryToRecurringEventVisitor.java
``` java

public class EntryToRecurringEventVisitor implements EntryVisitor<OldNewEntryPair> {

    private static final String ERROR_EMPTY_START = "Event start date time cannot be empty!";
    private static final String ERROR_EMPTY_END = "Event end date time cannot be empty!";
    private static final String ERROR_EMPTY_RECURRING = "Event recurring period cannot be empty!";

    private static final int LIMIT_INF = -2;
    private static final int LIMIT_DATE = -1;

    private final String name;
    private final LocalDateTime startDateTime;
    private final LocalDateTime endDateTime;
    private final Period recurringPeriod;
    private final int occurLimit;
    private final LocalDate limitDate;
    private final boolean isLimitKept;

    public EntryToRecurringEventVisitor(String name, LocalDateTime startDateTime, LocalDateTime endDateTime,
            Period recurringPeriod,
            boolean isLimitKept) {
        this.recurringPeriod = recurringPeriod;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.name = name;
        occurLimit = LIMIT_INF;
        limitDate = null;
        this.isLimitKept = isLimitKept;
    }

    public EntryToRecurringEventVisitor(String name, LocalDateTime startDateTime, LocalDateTime endDateTime,
            Period recurringPeriod, int occurLimit) {
        assert occurLimit > 0;

        this.name = name;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.recurringPeriod = recurringPeriod;
        this.occurLimit = occurLimit;
        this.limitDate = null;
        this.isLimitKept = false;
    }

    public EntryToRecurringEventVisitor(String name, LocalDateTime startDateTime, LocalDateTime endDateTime,
            Period recurringPeriod,
            LocalDate limitDate) {

        this.name = name;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
        this.recurringPeriod = recurringPeriod;
        this.occurLimit = LIMIT_DATE;
        this.limitDate = limitDate;
        this.isLimitKept = false;
    }

    @Override
    public OldNewEntryPair visit(GenericEntry entry) {
        if (startDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_START);
        }
        if (endDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_END);
        }
        if (recurringPeriod == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_RECURRING);
        }

        RecurringEvent event = new RecurringEvent(entry.getName(), startDateTime, endDateTime, recurringPeriod);
        event.setId(entry.getId());

        return edit(entry, event);
    }

    @Override
    public OldNewEntryPair visit(DeadlineTask task) {
        if (startDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_START);
        }
        if (recurringPeriod == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_RECURRING);
        }

        RecurringEvent event = new RecurringEvent(task.getName(), startDateTime,
                task.getDateTime(CalendarProperty.END), recurringPeriod);

        event.setId(task.getId());

        return edit(task, event);
    }

    @Override
    public OldNewEntryPair visit(RecurringTask task) {
        if (startDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_START);
        }

        RecurringEvent event = createRecurringEventFromRecurringTask(task);
        event.setId(task.getId());

        return edit(task, event);
    }

    @Override
    public OldNewEntryPair visit(Event event) {
        if (recurringPeriod == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_RECURRING);
        }

        RecurringEvent newEvent = new RecurringEvent(event.getName(), event.getDateTime(CalendarProperty.START),
                event.getDateTime(CalendarProperty.END), recurringPeriod);
        newEvent.setId(event.getId());

        return edit(event, newEvent);
    }

    @Override
    public OldNewEntryPair visit(RecurringEvent event) {
        RecurringEvent clone = new RecurringEvent(event);

        return edit(clone, event);
    }

    private OldNewEntryPair edit(CalendarEntry clone, RecurringEvent event) {
        if (name != null && !name.isEmpty()) {
            event.setName(name);
        }

        if (startDateTime != null) {
            event.setDateTime(CalendarProperty.START, startDateTime);
        }

        if (endDateTime != null) {
            event.setDateTime(CalendarProperty.END, endDateTime);
        }

        if (recurringPeriod != null) {
            event.setPeriod(recurringPeriod);
        }

        if (occurLimit == LIMIT_INF && !isLimitKept) {
            event.removeLimit();
        } else if (occurLimit == LIMIT_DATE && limitDate != null) {
            event.setDateTime(CalendarProperty.DATE_LIMIT, limitDate.atStartOfDay());
        } else if (occurLimit != LIMIT_INF && occurLimit != LIMIT_DATE) {
            event.setOccurrenceLimit(occurLimit);
        }

        return new OldNewEntryPair(clone, event);
    }

    private RecurringEvent createRecurringEventFromRecurringTask(RecurringTask task) {
        if (startDateTime == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_START);
        }

        RecurringEvent newEvent = new RecurringEvent(task.getName(), startDateTime,
                task.getDateTime(CalendarProperty.END), task.getPeriod());

        newEvent.setId(task.getId());

        if (task.isProperty(CalendarProperty.DATE_LIMITED)) {
            newEvent.setDateTime(CalendarProperty.DATE_LIMIT, task.getDateTime(CalendarProperty.DATE_LIMIT));
        } else if (task.isProperty(CalendarProperty.OCCURRENCE_LIMITED)) {
            newEvent.setOccurrenceLimit(task.getIntegerProperty(CalendarProperty.OCCURRENCE_LIMIT));
        }

        return newEvent;
    }
}
```
###### /src/lifetracker/calendar/visitor/EntryVisitor.java
``` java

public interface EntryVisitor<T> {
    T visit(GenericEntry entry);

    T visit(DeadlineTask task);

    T visit(RecurringTask task);

    T visit(Event event);

    T visit(RecurringEvent event);
}
```
###### /src/lifetracker/calendar/visitor/MarkVisitor.java
``` java

public class MarkVisitor implements EntryVisitor<OldNewEntryPair> {

    @Override
    public OldNewEntryPair visit(GenericEntry entry) {
        GenericEntry clone = new GenericEntry(entry);
        entry.toggleActive();
        return new OldNewEntryPair(clone, null);
    }

    @Override
    public OldNewEntryPair visit(DeadlineTask task) {
        DeadlineTask clone = new DeadlineTask(task);
        task.toggleActive();
        return new OldNewEntryPair(clone, null);
    }

    /**
     * This method mutates the input task into the next instance, then returns a pair containing a copy of the task
     * before it was mutated, as well as a new deadline task to be archived.
     *
     * @param task The recurring task to mark
     * @return A pair of entries, containing the un-mutated entry and the new entry
     */
    @Override
    public OldNewEntryPair visit(RecurringTask task) {
        RecurringTask clone = new RecurringTask(task);
        DeadlineTask doneTask = new DeadlineTask(task);
        doneTask.toggleActive();

        if (task.hasNext()) {
            //Set an invalid ID.
            doneTask.setId(CalendarList.BASE_ID);
            task.updateToNext();
        }

        return new OldNewEntryPair(clone, doneTask);
    }

    @Override
    public OldNewEntryPair visit(Event event) {
        Event clone = new Event(event);
        event.toggleActive();
        return new OldNewEntryPair(clone, null);
    }

    @Override
    public OldNewEntryPair visit(RecurringEvent event) {
        RecurringEvent clone = new RecurringEvent(event);
        Event doneEvent = recurringEventToEvent(event);
        doneEvent.toggleActive();

        if(event.hasNext()) {
            doneEvent.setId(CalendarList.BASE_ID);
            event.updateToNext();
        }
        return new OldNewEntryPair(clone, doneEvent);
    }

    private Event recurringEventToEvent(RecurringEvent event){
        Event newEvent = new Event(event.getName(), event.getDateTime(CalendarProperty.START), event.getDateTime(CalendarProperty.END));
        newEvent.setId(event.getId());
        return newEvent;
    }
}
```
###### /src/lifetracker/calendar/visitor/OldNewEntryPair.java
``` java

public class OldNewEntryPair {
    public CalendarEntry oldEntry;
    public CalendarEntry newEntry;

    public OldNewEntryPair(CalendarEntry oldEntry, CalendarEntry newEntry) {
        this.oldEntry = oldEntry;
        this.newEntry = newEntry;
    }

}
```
###### /src/lifetracker/calendar/visitor/VisitableEntry.java
``` java

public interface VisitableEntry {
    <T> T accept(EntryVisitor<T> visitor);
}
```
###### /src/lifetracker/calendar/visitor/EntryToDeadlineTaskVisitor.java
``` java

public class EntryToDeadlineTaskVisitor implements EntryVisitor<OldNewEntryPair> {

    private static final String ERROR_EMPTY_DEADLINE = "Task deadline cannot be empty!";

    private final String name;
    private final LocalDateTime deadline;
    private final boolean isConvertForced;

    public EntryToDeadlineTaskVisitor(String name, LocalDateTime deadline, boolean isConvertForced) {
        this.name = name;
        this.deadline = deadline;
        this.isConvertForced = isConvertForced;
    }

    @Override
    public OldNewEntryPair visit(GenericEntry entry) {
        if (deadline == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_DEADLINE);
        }

        DeadlineTask deadlineTask = new DeadlineTask(entry.getName(), entry.getDateTime(CalendarProperty.END));
        deadlineTask.setId(entry.getId());

        return edit(entry, deadlineTask);
    }

    @Override
    public OldNewEntryPair visit(DeadlineTask task) {
        DeadlineTask clone = new DeadlineTask(task);
        return edit(clone, task);
    }

    @Override
    public OldNewEntryPair visit(RecurringTask task) {
        RecurringTask clone = new RecurringTask(task);
        return edit(clone, task);
    }

    @Override
    public OldNewEntryPair visit(Event event) {
        Event clone = new Event(event);
        return edit(clone, event);
    }

    @Override
    public OldNewEntryPair visit(RecurringEvent event) {
        RecurringEvent clone = new RecurringEvent(event);
        return edit(clone, event);
    }

    private OldNewEntryPair edit(CalendarEntry clone, DeadlineTask task) {
        DeadlineTask convertedTask = task;
        if (isConvertForced) {
            convertedTask = new DeadlineTask(convertedTask);
        }

        if(name != null && !name.isEmpty()){
            convertedTask.setName(name);
        }

        if (deadline!=null){
            convertedTask.setDateTime(CalendarProperty.END, deadline);
        }

        return new OldNewEntryPair(clone, convertedTask);
    }
}
```
###### /src/lifetracker/calendar/visitor/EntryToGenericTaskVisitor.java
``` java

public class EntryToGenericTaskVisitor implements EntryVisitor<OldNewEntryPair> {

    private String name;
    private boolean isConvertForced;

    public EntryToGenericTaskVisitor(String name, boolean isConvertForced) {
        this.name = name;
        this.isConvertForced = isConvertForced;
    }

    @Override
    public OldNewEntryPair visit(GenericEntry entry) {
        GenericEntry clone = new GenericEntry(entry);

        return edit(clone, entry);
    }

    @Override
    public OldNewEntryPair visit(DeadlineTask task) {
        DeadlineTask clone = new DeadlineTask(task);

        return edit(clone, task);
    }

    @Override
    public OldNewEntryPair visit(RecurringTask task) {
        RecurringTask clone = new RecurringTask(task);

        return edit(clone, task);
    }

    @Override
    public OldNewEntryPair visit(Event event) {
        Event clone = new Event(event);

        return edit(clone, event);
    }

    @Override
    public OldNewEntryPair visit(RecurringEvent event) {
        RecurringEvent clone = new RecurringEvent(event);

        return edit(clone, event);
    }

    private OldNewEntryPair edit(CalendarEntry clone, GenericEntry newEntry) {
        GenericEntry convertedEntry = newEntry;
        if (isConvertForced){
            convertedEntry = new GenericEntry(convertedEntry);
        }

        if (name != null && !name.isEmpty()) {
            convertedEntry.setName(name);
        }

        return new OldNewEntryPair(clone, convertedEntry);
    }
}
```
###### /src/lifetracker/calendar/visitor/EntryToRecurringTaskVisitor.java
``` java

public class EntryToRecurringTaskVisitor implements EntryVisitor<OldNewEntryPair> {

    private static final String ERROR_EMPTY_DEADLINE = "Task deadline cannot be empty!";
    private static final String ERROR_EMPTY_RECURRING = "Task recurring period cannot be empty!";

    private static final int LIMIT_INF = -2;
    private static final int LIMIT_DATE = -1;

    private final String name;
    private final LocalDateTime deadline;
    private final Period recurringPeriod;
    private final int occurLimit;
    private final LocalDate limitDate;
    private final boolean isConvertForced;
    private final boolean isLimitKept;

    public EntryToRecurringTaskVisitor(String name, LocalDateTime deadLine, Period recurringPeriod,
            boolean isLimitKept, boolean isConvertForced) {
        this.recurringPeriod = recurringPeriod;
        this.deadline = deadLine;
        this.name = name;
        occurLimit = LIMIT_INF;
        limitDate = null;
        this.isLimitKept = isLimitKept;
        this.isConvertForced = isConvertForced;
    }

    public EntryToRecurringTaskVisitor(String name, LocalDateTime deadLine, Period recurringPeriod, int occurLimit,
            boolean isConvertForced) {
        assert occurLimit > 0;

        this.name = name;
        this.deadline = deadLine;
        this.recurringPeriod = recurringPeriod;
        this.occurLimit = occurLimit;
        this.limitDate = null;
        this.isLimitKept = false;
        this.isConvertForced = isConvertForced;
    }

    public EntryToRecurringTaskVisitor(String name, LocalDateTime deadLine, Period recurringPeriod,
            LocalDate limitDate, boolean isConvertForced) {

        this.name = name;
        this.deadline = deadLine;
        this.recurringPeriod = recurringPeriod;
        this.occurLimit = LIMIT_DATE;
        this.limitDate = limitDate;
        this.isLimitKept = false;
        this.isConvertForced = isConvertForced;
    }

    @Override
    public OldNewEntryPair visit(GenericEntry entry) {
        if (deadline == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_DEADLINE);
        }

        if (recurringPeriod == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_RECURRING);
        }

        RecurringTask newTask = new RecurringTask(entry.getName(), deadline, recurringPeriod);
        newTask.setId(entry.getId());
        return edit(entry, newTask);
    }

    @Override
    public OldNewEntryPair visit(DeadlineTask task) {
        if (recurringPeriod == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_RECURRING);
        }

        RecurringTask newTask = new RecurringTask(task.getName(), task.getDateTime(CalendarProperty.END),
                recurringPeriod);
        newTask.setId(task.getId());
        return edit(task, newTask);
    }

    @Override
    public OldNewEntryPair visit(RecurringTask task) {
        RecurringTask clone = new RecurringTask(task);
        return edit(clone, task);
    }

    @Override
    public OldNewEntryPair visit(Event event) {
        if (recurringPeriod == null) {
            throw new IllegalArgumentException(ERROR_EMPTY_RECURRING);
        }

        if (isConvertForced) {
            OldNewEntryPair pair = visit(new DeadlineTask(event));
            pair.oldEntry = event;
            return pair;
        } else {
            RecurringEvent newEvent = new RecurringEvent(
                    event.getName(),
                    event.getDateTime(CalendarProperty.START),
                    event.getDateTime(CalendarProperty.END),
                    recurringPeriod);

            newEvent.setId(event.getId());

            return edit(event, newEvent);
        }
    }

    @Override
    public OldNewEntryPair visit(RecurringEvent event) {
        RecurringEvent clone = new RecurringEvent(event);
        return edit(clone, event);
    }

    private OldNewEntryPair edit(CalendarEntry clone, RecurringTask task) {
        RecurringTask convertedTask = task;
        if (isConvertForced) {
            convertedTask = new RecurringTask(convertedTask);
        }

        if (name != null && !name.isEmpty()) {
            convertedTask.setName(name);
        }

        if (deadline != null) {
            convertedTask.setDateTime(CalendarProperty.END, deadline);
        }

        if (recurringPeriod != null) {
            convertedTask.setPeriod(recurringPeriod);
        }

        if (occurLimit == LIMIT_INF && !isLimitKept) {
            convertedTask.removeLimit();
        } else if (occurLimit == LIMIT_DATE && limitDate!=null) {
            convertedTask.setDateTime(CalendarProperty.DATE_LIMIT, limitDate.atStartOfDay());
        } else if (occurLimit != LIMIT_INF && occurLimit != LIMIT_DATE) {
            convertedTask.setOccurrenceLimit(occurLimit);
        }

        return new OldNewEntryPair(clone, convertedTask);
    }
}
```
###### /src/lifetracker/parser/datetime/DateTimeParser.java
``` java

/**
 * A parser that parses DateTime strings.
 * <p>
 * This class uses natty to parse date and time strings. After parsing, the
 * datetimes are adjusted accordingly based on the method's defaults.
 * <p>
 * Refer to the method descriptions themselves.
 *
 * @see #parseSingleDateTime(String)
 * @see #parseDateTimeAsIs(String)
 * @see #parseDoubleDateTime(String, String)
 */
public class DateTimeParser {
    private static final String EMPTY_DATE_DEFAULT_STRING = "today";
    private static final String NATTY_TIME_FIELD = "explicit_time";
    private static final String NATTY_DATE_FIELD = "date";
    private static final String NATTY_MERIDIAN_INDICATOR = "meridian_indicator";

    //Natty parses "1" as 1am, but "12" as 12pm so there's no need to adjust
    private static final LocalTime UNGODLY_HOUR_START = LocalTime.of(0, 59, 59);
    private static final LocalTime UNGODLY_HOUR_END = LocalTime.of(7, 0);

    private static DateTimeParser instance = new DateTimeParser();
    private final com.joestelmach.natty.Parser nattyParser = new com.joestelmach.natty.Parser();

    public static DateTimeParser getInstance() {
        return instance;
    }

    private DateTimeParser() {
    }

    /**
     * Determines is a String can be parsed as a DateTime.
     * <p>
     * Note that empty Strings are replaced with defaults in this class and are thus considered valid Strings.
     *
     * @param dateTimeString The String to test
     * @return If the String can be parsed by this class as a date time
     */
    public boolean isDateTime(String dateTimeString) {
        assert dateTimeString != null;

        return dateTimeString.isEmpty() || nattyParser.parse(dateTimeString).size() == 1;
    }

    /**
     * Parses a single date time string.
     * <p>
     * It is then adjusted to the rules as specified below:
     * <p>
     * <ul>
     * <li>If original string did not specify time, time is set to 2359
     * <li>If original string did not specify date, date is set to the next date
     * where the DateTime is in the future.
     * </ul>
     *
     * @param dateTimeString The date time string
     * @return The result from parsing the string
     */
    public LocalDateTime parseSingleDateTime(String dateTimeString) {
        assert isDateTime(dateTimeString);

        dateTimeString = fillEmpty(dateTimeString);

        DateGroup parsedDateGroup = parseWithNatty(dateTimeString);

        LocalDateTime parsedDateTimeObj = convertDateGroupToLocalDateTime(parsedDateGroup);

        return adjustSingleDateToDefault(parsedDateTimeObj, parsedDateGroup.getParseLocations().keySet());
    }

    /**
     * Parses two datetime Strings with one as a start date and one as an end date.
     * <p>
     * The dates are first adjusted to defaults, then to each other, as the rules below:
     * <p>
     * <ul>
     * <li>If end time is missing, the end DateTime defaults to one hour after start if they are on the same day, or to
     * the same time if they are on different days.
     * <li>If end date is missing, it defaults to the first date where start DateTime is before end DateTime.
     * <li>Start date/time, if missing, is adjusted to one hour before the end date/time if they fall on the same date,
     * or at the same date if they are determined to be on different dates.
     * <li>If both are missing, both date times are adjusted such that they are one hour apart at least, with the start
     * time adjusted to the next hour if no time is specified.
     * </ul>
     *
     * @param startString The String representing the start date/time
     * @param endString   The String representing the end date/time
     * @return A list with 2 {@code LocalDateTime}s, which are the start and end dates respectively.
     */
    public List<LocalDateTime> parseDoubleDateTime(String startString, String endString) {
        assert isDateTime(startString);
        assert isDateTime(endString);

        List<LocalDateTime> dateTimeResults = new ArrayList<>(2);

        boolean isEndEmpty = StringUtils.isBlank(endString);
        boolean isStartEmpty = StringUtils.isBlank(startString);

        startString = fillEmpty(startString);
        endString = fillEmpty(endString);

        DateGroup startDateGroup = parseWithNatty(startString);
        DateGroup endDateGroup = parseWithNatty(endString);

        LocalDateTime startDateTime = convertDateGroupToLocalDateTime(startDateGroup);
        LocalDateTime endDateTime = convertDateGroupToLocalDateTime(endDateGroup);

        Set<String> startParseElements = isStartEmpty ?
                Collections.emptySet() :
                startDateGroup.getParseLocations().keySet();
        // If end datetime was empty to begin with, we have to pretend nothing was parsed.
        Set<String> endParseElements = isEndEmpty ? Collections.emptySet() : endDateGroup.getParseLocations().keySet();

        LocalDateTime[] adjustedDates = adjustDoubleDateToDefault(startDateTime, endDateTime, startParseElements,
                endParseElements);

        dateTimeResults.addAll(Arrays.asList(adjustedDates));

        return dateTimeResults;
    }

    /**
     * Parses a date/time from a String without any adjustments.
     * <p>
     * The defaults from natty will be directly returned.
     *
     * @param dateTimeString The date/time String to parse
     * @return The date/time produced as by natty
     */
    public LocalDateTime parseDateTimeAsIs(String dateTimeString) {
        DateGroup parsedDateGroup = parseWithNatty(dateTimeString);

        return convertDateGroupToLocalDateTime(parsedDateGroup);
    }

    private String fillEmpty(String dateTimeString) {
        if (dateTimeString == null || dateTimeString.isEmpty()) {
            return EMPTY_DATE_DEFAULT_STRING;
        } else {
            return dateTimeString;
        }
    }

    private DateGroup parseWithNatty(String dateTimeString) {
        return nattyParser.parse(dateTimeString).get(0);
    }

    private LocalDateTime convertDateGroupToLocalDateTime(DateGroup dateGroup) {
        Date date = dateGroup.getDates().get(0);

        return LocalDateTime.ofInstant(date.toInstant(), ZoneId.systemDefault());
    }

    /**
     * This method looks at the parseElements to determine with fields are explicitly specified, and then replaces
     * field
     * not explicitly specified with default values (Today's date and 2359).
     *
     * @param dateTime      The date/time to begin with
     * @param parseElements The parse map from natty
     * @return The adjusted date/time
     */
    private LocalDateTime adjustSingleDateToDefault(LocalDateTime dateTime, Set<String> parseElements) {

        dateTime = fillDefaultDateTime(dateTime, LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT.minusMinutes(1)),
                parseElements);

        dateTime = adjustDateAfterReferenceByDays(dateTime, LocalDateTime.now().withNano(0), parseElements);

        dateTime = adjustAmPm(dateTime, parseElements);

        return dateTime;
    }

    /**
     * Adjusts two date times with respect to each other, for fields that are not explicitly specified, as from their
     * parse maps.
     * <p>
     * This method adjusts two date/times such that non-explicit date/times are adjusted based on either other
     * explicitly stated fields, or based the next hour from the time now.
     *
     * @param startDateTime      The initial start date/time String
     * @param endDateTime        The initial end date/time String
     * @param startParseElements The natty parse map for the start date/time
     * @param endParseElements   The natty parse map for the end date/time
     * @return A array of two {@code LocalDateTime}s representing the start and end date/times
     */
    private LocalDateTime[] adjustDoubleDateToDefault(LocalDateTime startDateTime, LocalDateTime endDateTime,
            Set<String> startParseElements, Set<String> endParseElements) {

        LocalDateTime adjustedStart;
        LocalDateTime adjustedEnd;
        LocalDateTime defaultDateTime = LocalDateTime.now().plusHours(1).withMinute(0).withSecond(0).withNano(0);

        //Fill in proper default dates
        adjustedStart = fillDefaultDateTime(startDateTime, defaultDateTime, startParseElements);
        adjustedEnd = fillDefaultDateTime(endDateTime, adjustedStart, endParseElements);
        adjustedEnd = adjustTimeAfterReferenceOneHour(adjustedEnd, adjustedStart, endParseElements);

        //To adjust the start time properly
        adjustedStart = fillDefaultDateTime(adjustedStart, adjustedEnd, startParseElements);
        adjustedStart = adjustTimeBeforeReferenceOneHour(adjustedStart, adjustedEnd, startParseElements);

        adjustedEnd = adjustTimeAfterReferenceOneHour(adjustedEnd, adjustedStart, endParseElements);
        adjustedEnd = adjustDateAfterReferenceByDays(adjustedEnd, adjustedStart, endParseElements);

        if (adjustedEnd.isBefore(LocalDateTime.now())) {
            // jointParse will detect if both dates can be adjusted
            Set<String> jointParse = new HashSet<>(startParseElements);
            jointParse.addAll(endParseElements);

            adjustedStart = adjustDateAfterReferenceByDays(adjustedStart, defaultDateTime,
                    jointParse);
            adjustedEnd = adjustDateAfterReferenceByDays(adjustedEnd, defaultDateTime,
                    jointParse);
        }

        adjustedStart = adjustAmPm(adjustedStart, startParseElements);
        adjustedEnd = adjustAmPm(adjustedEnd, endParseElements);

        return new LocalDateTime[] {adjustedStart, adjustedEnd};
    }

    /**
     * Fill in non-explicit fields of the date/time given with field from the default date/time specified.
     *
     * @param dateTime        The initial date/time
     * @param defaultDateTime The default date/time
     * @param parseElements   The natty parse map
     * @return The adjusted date/time
     */
    private LocalDateTime fillDefaultDateTime(LocalDateTime dateTime, LocalDateTime defaultDateTime,
            Set<String> parseElements) {
        LocalDateTime adjustedDateTime = dateTime;

        if (!parseElements.contains(NATTY_TIME_FIELD)) {
            adjustedDateTime = LocalDateTime.of(adjustedDateTime.toLocalDate(), defaultDateTime.toLocalTime());
        }

        if (!parseElements.contains(NATTY_DATE_FIELD)) {
            adjustedDateTime = LocalDateTime.of(defaultDateTime.toLocalDate(), adjustedDateTime.toLocalTime());
        }

        return adjustedDateTime;
    }

    private LocalDateTime adjustAmPm(LocalDateTime dateTime, Set<String> parseElements) {

        LocalDateTime adjustedDateTime = dateTime.withNano(0);

        if (!parseElements.contains(NATTY_MERIDIAN_INDICATOR) && parseElements.contains(NATTY_TIME_FIELD)) {
            LocalTime time = dateTime.toLocalTime();

            if (time.isAfter(UNGODLY_HOUR_START) && time.isBefore(UNGODLY_HOUR_END)) {
                time = time.plusHours(12);
                adjustedDateTime = LocalDateTime.of(dateTime.toLocalDate(), time);
            }
        }

        return adjustedDateTime;
    }

    private LocalDateTime adjustDateAfterReferenceByDays(LocalDateTime dateTime, LocalDateTime reference,
            Set<String> parseElements) {
        if (!parseElements.contains(NATTY_DATE_FIELD)) {
            while (dateTime.isBefore(reference)) {
                dateTime = dateTime.plusDays(1);
            }
        }

        return dateTime;
    }

    private LocalDateTime adjustTimeAfterReferenceOneHour(LocalDateTime dateTime, LocalDateTime reference,
            Set<String> parseElements) {
        if (!parseElements.contains(NATTY_TIME_FIELD)
                && (dateTime.isBefore(reference) || dateTime.isEqual(reference))) {

            if (parseElements.contains(NATTY_DATE_FIELD)) {
                dateTime = LocalDateTime.of(dateTime.toLocalDate(), reference.toLocalTime().plusHours(1));
            } else {
                dateTime = reference.plusHours(1);
            }

        }

        return dateTime;
    }

    private LocalDateTime adjustTimeBeforeReferenceOneHour(LocalDateTime dateTime, LocalDateTime reference,
            Set<String> parseElements) {
        LocalDateTime tempDateTime = dateTime;
        if (!parseElements.contains(NATTY_TIME_FIELD)
                && (tempDateTime.isAfter(reference) || tempDateTime.isEqual(reference))) {

            if (parseElements.contains(NATTY_DATE_FIELD)) {
                tempDateTime = LocalDateTime.of(tempDateTime.toLocalDate(), reference.toLocalTime().minusHours(1));
            } else {
                tempDateTime = reference.minusHours(1);
            }
        }

        return tempDateTime;
    }
}
```
###### /src/lifetracker/parser/datetime/DurationParser.java
``` java

/**
 * This Singleton class parses duration Strings into {@code Period} objects.
 * <p>
 * Examples of duration Strings are "1 week", "year", "3 days".
 */
public class DurationParser {
    private static DurationParser ourInstance = new DurationParser();
    private static final String FORMAT_ERROR = "Invalid duration format!";
    private final String DURATION_PATTERN = "(\\d+\\s+)?\\w+";
    private final String TERM_SEPARATOR_PATTERN = "\\s+";
    private Map<String, Function<Integer, Period>> parserMap = new HashMap<>();

    /**
     * Gets the instance of this Singleton class.
     *
     * @return The instance of this class
     */
    public static DurationParser getInstance() {
        return ourInstance;
    }

    private DurationParser() {
        parserMap.put("year", Period::ofYears);
        parserMap.put("month", Period::ofMonths);
        parserMap.put("week", Period::ofWeeks);
        parserMap.put("day", Period::ofDays);
    }

    /**
     * Detects if the String provided is a duration.
     *
     * @param durationString The String to check
     * @return {@code true} if the String is a duration
     */
    public boolean isDuration(String durationString) {
        try {
            parse(durationString);
        } catch (IllegalArgumentException ex) {
            return false;
        }
        return true;
    }

    /**
     * Parses the String into a {@code Period}
     *
     * @param durationString The duration string to parse
     * @return The {@code Period} object
     * @see Period
     */
    public Period parse(String durationString) {

        if (!isValidFormat(durationString)) {
            throw new IllegalArgumentException(FORMAT_ERROR);
        }

        int num = getNum(durationString);
        String expression = getDurationExpression(durationString);

        if (parserMap.containsKey(expression) && num > 0) {
            return parserMap.get(expression).apply(num);
        } else {
            throw new IllegalArgumentException(FORMAT_ERROR);
        }
    }

    private boolean isValidFormat(String durationString) {
        return durationString != null && durationString.matches(DURATION_PATTERN);
    }

    private int getNum(String durationString) {
        String[] splitString = durationString.split(TERM_SEPARATOR_PATTERN);

        if (splitString.length == 1) {
            return 1;
        } else {
            return Integer.parseInt(splitString[0]);
        }
    }

    private String getDurationExpression(String durationString) {
        String[] splitString = durationString.split(TERM_SEPARATOR_PATTERN);

        if (splitString.length == 1) {
            return singularize(splitString[0]);
        } else {
            return singularize(splitString[1]);
        }
    }

    private String singularize(String word) {
        String singularWord = word.trim();

        if (!singularWord.isEmpty() && singularWord.charAt(singularWord.length() - 1) == 's') {
            return singularWord.substring(0, singularWord.length() - 1);
        } else {
            return singularWord;
        }
    }
}
```
###### /src/lifetracker/parser/syntax/AddParameterParser.java
``` java

/**
 * The parameters parser for "add" command.
 */
public class AddParameterParser extends EditOneParametersParser {
    private static AddParameterParser ourInstance = new AddParameterParser();

    public static AddParameterParser getInstance() {
        return ourInstance;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Parameters parseCommandMap(Map<CommandOptions, String> commandMap) {
        assert commandMap.containsKey(CommandOptions.NAME);

        Parameters result = new Parameters();
        result.name = commandMap.get(CommandOptions.NAME);

        determineTypeAndPopulateFields(commandMap, result);

        return result;
    }

    /**
     * {@inheritDoc}
     */
    protected void determineTypeAndPopulateFields(Map<CommandOptions, String> commandMap, Parameters result) {

        super.determineTypeAndPopulateFields(commandMap, result);

        if (isRecurringMap(commandMap)) {

            if (result.commandClass == CommandClass.GENERIC) {
                fillUpTaskNull(commandMap);
                populateTaskParameters(commandMap, result);
            }

            populateRecurringParameters(commandMap, result);
        }
    }

    protected void fillUpTaskNull(Map<CommandOptions, String> commandMap) {
        if (!commandMap.containsKey(CommandOptions.BY)) {
            commandMap.put(CommandOptions.BY, "");
        }
    }

    protected boolean isRecurringMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, CommandOptions.UNTIL, CommandOptions.FOR);

        return commandMap.containsKey(CommandOptions.EVERY);
    }

    protected void populateRecurringParameters(Map<CommandOptions, String> commandMap, Parameters result) {

        result.recurringPeriod = durationParser.parse(commandMap.get(CommandOptions.EVERY));

        if (commandMap.containsKey(CommandOptions.UNTIL)) {
            result.dateLimit = dateTimeParser.parseDateTimeAsIs(commandMap.get(CommandOptions.UNTIL)).toLocalDate();

            assignRecurringClass(commandMap, result, CommandClass.RECURRING_EVENT_DATE,
                    CommandClass.RECURRING_TASK_DATE);
        } else if (commandMap.containsKey(CommandOptions.FOR)) {
            result.occurLimit = Integer.parseInt(commandMap.get(CommandOptions.FOR));

            assignRecurringClass(commandMap, result, CommandClass.RECURRING_EVENT_OCCURRENCES,
                    CommandClass.RECURRING_TASK_OCCURRENCES);
        } else {
            assignRecurringClass(commandMap, result, CommandClass.RECURRING_EVENT, CommandClass.RECURRING_TASK);
        }
    }

    private void assignRecurringClass(Map<CommandOptions, String> commandMap, Parameters result, CommandClass eventEnum,
            CommandClass taskEnum) {
        if (isEventMap(commandMap)) {
            result.commandClass = eventEnum;
        } else {
            result.commandClass = taskEnum;
        }
    }
}
```
###### /src/lifetracker/parser/syntax/CommandClass.java
``` java
/**
 * The different types of Commands.
 */
public enum CommandClass {
    GENERIC,
    DEADLINE,
    EVENT,
    RECURRING_EVENT,
    RECURRING_EVENT_OCCURRENCES,
    RECURRING_EVENT_DATE,
    RECURRING_TASK,
    RECURRING_TASK_OCCURRENCES,
    RECURRING_TASK_DATE,
    RECURRING,
    RECURRING_OCCURRENCES,
    RECURRING_DATE,
    STOP_RECURRING
}
```
###### /src/lifetracker/parser/syntax/CommandOptions.java
``` java

/**
 * The options that a command can contain.
 */
public enum CommandOptions {
    NAME,
    FROM,
    TO,
    BY,
    EVERY,
    FOR,
    UNTIL,
    NODUE,
    FOREVER,
    STOP,
    TODAY
}
```
###### /src/lifetracker/parser/syntax/CommandParametersParser.java
``` java

/**
 * CommandParametersParser parses a map of parameter option/values into a {@code Parameters} object.
 *
 * @see Parameters
 */
public interface CommandParametersParser {
    String ERROR_INVALID_PARAMS = "Keywords provided are not valid together!";

    /**
     * Parses the command map into a corresponding {@code Parameters} object based on the mpa entries.
     * @param commandMap The map with options mapped to values.
     * @return A corresponding {@code Parameters} Object
     */
    Parameters parseCommandMap(Map<CommandOptions, String> commandMap);

    static void checkMutuallyExclusiveKeywords(Map<CommandOptions, String> commandMap, CommandOptions... options) {
        int count = 0;
        for (CommandOptions option : options) {
            if (commandMap.containsKey(option)) {
                count++;
            }
        }

        if (count > 1) {
            throw new IllegalArgumentException(ERROR_INVALID_PARAMS);
        }
    }

}
```
###### /src/lifetracker/parser/syntax/CommandSectionParser.java
``` java

/**
 * This class parses a section of the command.
 * <p>
 * It extracts the parameters from the command, checks that their values are valid, and organises them into a map
 * indexed by {@code CommandOptions} to the values of these parameters.
 */
public class CommandSectionParser<T extends Enum<T>> {

    private static final String COMMAND_BODY_SEPARATOR = " ";

    private final Map<T, Predicate<String>> verificationMap;
    private final Map<String, T> keywordToEnumMap;
    private final T defaultField;

    /**
     * Creates a new {@code CommandSectionParser}, based on the mapping given.
     *
     * @param keywordToEnumMap A map that links keywords to enums.
     * @param verificationMap  A map with predicates for verifying the values of parameters
     * @param defaultField     The default field to put all other values without options into
     */
    public CommandSectionParser(Map<String, T> keywordToEnumMap, Map<T, Predicate<String>> verificationMap,
            T defaultField) {
        this.verificationMap = verificationMap;
        this.keywordToEnumMap = keywordToEnumMap;
        this.defaultField = defaultField;
    }

    /**
     * Parses the command body using the keywords supplied to this object.
     * <p>
     * This method parses the command from the back.
     * <p>
     * Arguments after a keyword is checked with the keyword predicate specified for validity. An invalid argument,
     * repeated keyword, or end list will trigger the method to dump the arguments, together with the rest of the
     * command into a entry accessible with key "name".
     * <p>
     * The method returns a map that can be iterated in parse order (i.e. components iterated from the back of the
     * command). The keys are the keywords and the values are the arguments.
     *
     * @param commandBody The command body to parse
     * @return A map with the components parsed
     */
    public Map<T, String> parseCommandSection(String commandBody) {

        Map<T, String> keyWordArgumentMap = new LinkedHashMap<>();

        Deque<String> processStack = commandBodyToDeque(commandBody);
        Deque<String> intermediateStack = new LinkedList<>();

        while (!processStack.isEmpty()) {
            String element = processStack.removeLast();
            T field = keywordToEnumMap.get(element);

            if (field != null && verificationMap.containsKey(field)) {

                String argument = collapseDeque(intermediateStack);
                intermediateStack.clear();

                if (verificationMap.get(field).test(argument) && !keyWordArgumentMap.containsKey(field)) {
                    keyWordArgumentMap.put(field, argument);
                } else {
                    processStack.add(element);
                    processStack.add(argument);

                    keyWordArgumentMap.put(defaultField, collapseDeque(processStack));
                    processStack.clear();
                }
            } else {
                intermediateStack.push(element);
            }
        }

        if (!keyWordArgumentMap.containsKey(defaultField)) {
            keyWordArgumentMap.put(defaultField, collapseDeque(intermediateStack));
        }

        return keyWordArgumentMap;
    }

    /**
     * Creates a stack from the command body, split into elements and pops from the back.
     *
     * @param commandBody The command body
     * @return The reverse stack
     */
    private static Deque<String> commandBodyToDeque(String commandBody) {
        String[] splitCommand = commandBody.split(COMMAND_BODY_SEPARATOR);

        Deque<String> processStack = new LinkedList<>();

        Collections.addAll(processStack, splitCommand);

        return processStack;
    }

    private static String collapseDeque(Deque<String> list) {
        StringBuilder collateString = new StringBuilder();

        for (String elem : list) {
            collateString.append(elem);
            collateString.append(" ");
        }

        return collateString.toString().trim();
    }

}
```
###### /src/lifetracker/parser/syntax/EditOneParametersParser.java
``` java

/**
 * The parameters parser for the "editone" command.
 */
public class EditOneParametersParser implements CommandParametersParser {

    private static EditOneParametersParser ourInstance = new EditOneParametersParser();
    protected final DateTimeParser dateTimeParser = DateTimeParser.getInstance();
    protected final DurationParser durationParser = DurationParser.getInstance();

    /**
     * Gets the instance of this Singleton class.
     *
     * @return The instance of this class
     */
    public static EditOneParametersParser getInstance() {
        return ourInstance;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Parameters parseCommandMap(Map<CommandOptions, String> commandMap) {
        Parameters results = new Parameters();
        results.name = commandMap.get(NAME);

        determineTypeAndPopulateFields(commandMap, results);

        return results;
    }

    /**
     * Determines the correct "add" {@code CommandObject} to create based on the {@code CommandClass} specified in the
     * given {@code Paramaters} object.
     *
     * @param params The Parameters object.
     * @return The correct "add" {@code CommandObject}
     * @see Parameters
     * @see lifetracker.parser.syntax.CommandClass
     */
    protected void determineTypeAndPopulateFields(Map<CommandOptions, String> commandMap, Parameters results) {
        if (isEventMap(commandMap)) {
            fillUpEventNull(commandMap);
            populateEventParameters(commandMap, results);
        } else if (isTaskMap(commandMap)) {
            populateTaskParameters(commandMap, results);
        } else {
            results.commandClass = CommandClass.GENERIC;
        }
    }

    protected boolean isTaskMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, BY, FROM);
        checkMutuallyExclusiveKeywords(commandMap, BY, TO);

        return commandMap.containsKey(BY);
    }

    protected boolean isEventMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, FROM, BY);

        return commandMap.containsKey(FROM);
    }

    protected void populateEventParameters(Map<CommandOptions, String> commandMap, Parameters result) {
        List<LocalDateTime> startEndDateTime = dateTimeParser
                .parseDoubleDateTime(commandMap.get(FROM), commandMap.get(TO));

        result.startDateTime = startEndDateTime.get(0);
        result.endDateTime = startEndDateTime.get(1);
        result.commandClass = CommandClass.EVENT;
    }

    protected void fillUpEventNull(Map<CommandOptions, String> commandMap) {
        if (!commandMap.containsKey(FROM)) {
            commandMap.put(FROM, "");
        }

        if (!commandMap.containsKey(TO)) {
            commandMap.put(TO, "");
        }
    }

    protected void populateTaskParameters(Map<CommandOptions, String> commandMap, Parameters result) {
        result.endDateTime = dateTimeParser.parseSingleDateTime(commandMap.get(BY));
        result.commandClass = CommandClass.DEADLINE;
    }
}
```
###### /src/lifetracker/parser/syntax/EditParameterParser.java
``` java

/**
 * The parameters parser for the "edit" command.
 */
public class EditParameterParser extends AddParameterParser {
    private static EditParameterParser ourInstance = new EditParameterParser();

    /**
     * Gets the instance of this Singleton class.
     * @return The instance of this class.
     */
    public static EditParameterParser getInstance() {
        return ourInstance;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Parameters parseCommandMap(Map<CommandOptions, String> commandMap) {
        Parameters result = new Parameters();

        result.name = commandMap.get(NAME);

        determineTypeAndPopulateFields(commandMap, result);

        return result;
    }

    /**
     * {@inheritDoc}
     */
    protected void determineTypeAndPopulateFields(Map<CommandOptions, String> commandMap, Parameters result) {
        if (isEventMap(commandMap)) {
            fillUpEventNull(commandMap);
            populateEventParameters(commandMap, result);
            resolveAndProcessRecurringCommandType(commandMap, result);
        } else if (isTaskMap(commandMap)) {
            populateTaskParameters(commandMap, result);
            resolveAndProcessRecurringCommandType(commandMap, result);
        } else {
            result.commandClass = GENERIC;
            if (isRemoveDateMap(commandMap)) {
                result.isForcedOverwrite = true;
            } else {
                resolveAndProcessRecurringCommandType(commandMap, result);
                if (isStopMap(commandMap)) {
                    result.commandClass = STOP_RECURRING;
                }
            }
        }
    }

    @Override
    protected boolean isRecurringMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, NODUE, EVERY);
        checkMutuallyExclusiveKeywords(commandMap, FOREVER, FOR, UNTIL);
        checkMutuallyExclusiveKeywords(commandMap, STOP, EVERY);

        return super.isRecurringMap(commandMap)
                || commandMap.containsKey(FOR)
                || commandMap.containsKey(UNTIL);
    }

    @Override
    protected boolean isEventMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, BY, NODUE);
        return super.isEventMap(commandMap);
    }

    @Override
    protected boolean isTaskMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, FROM, NODUE);
        checkMutuallyExclusiveKeywords(commandMap, TO, NODUE);
        return super.isTaskMap(commandMap);
    }

    @Override
    protected void populateRecurringParameters(Map<CommandOptions, String> commandMap, Parameters result) {

        if (commandMap.containsKey(EVERY)) {
            result.recurringPeriod = durationParser.parse(commandMap.get(EVERY));
        }

        if (commandMap.containsKey(UNTIL)) {
            result.dateLimit = dateTimeParser.parseDateTimeAsIs(commandMap.get(UNTIL)).toLocalDate();

            assignRecurringClass(commandMap, result, RECURRING_EVENT_DATE,
                    RECURRING_TASK_DATE, RECURRING_DATE);

        } else if (commandMap.containsKey(FOR)) {
            result.occurLimit = Integer.parseInt(commandMap.get(FOR));

            assignRecurringClass(commandMap, result, RECURRING_EVENT_OCCURRENCES,
                    RECURRING_TASK_OCCURRENCES, RECURRING_OCCURRENCES);
        } else {
            assignRecurringClass(commandMap, result, RECURRING_EVENT, RECURRING_TASK, RECURRING);
        }
    }

    protected boolean isStopMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, STOP, EVERY);
        checkMutuallyExclusiveKeywords(commandMap, FOR, UNTIL,FOREVER);

        return commandMap.containsKey(STOP);
    }

    protected boolean isUnlimitMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, FOR, UNTIL, FOREVER);

        return commandMap.containsKey(FOREVER);
    }

    protected boolean isRemoveDateMap(Map<CommandOptions, String> commandMap) {
        checkMutuallyExclusiveKeywords(commandMap, BY, NODUE);
        checkMutuallyExclusiveKeywords(commandMap, TO, NODUE);
        checkMutuallyExclusiveKeywords(commandMap, FROM, NODUE);
        checkMutuallyExclusiveKeywords(commandMap, EVERY, NODUE);
        checkMutuallyExclusiveKeywords(commandMap, FOR, NODUE);
        checkMutuallyExclusiveKeywords(commandMap, UNTIL, NODUE);

        return commandMap.containsKey(NODUE);
    }

    private void resolveAndProcessRecurringCommandType(Map<CommandOptions, String> commandMap, Parameters result) {
        if (isRecurringMap(commandMap)) {
            populateRecurringParameters(commandMap, result);
        } else if (isUnlimitMap(commandMap)) {
            populateRecurringParameters(commandMap, result);
            result.isForcedOverwrite = true;
        } else if (isStopMap(commandMap)) {
            result.isForcedOverwrite = true;
        }
    }

    private void assignRecurringClass(Map<CommandOptions, String> commandMap, Parameters result, CommandClass eventEnum,
            CommandClass taskEnum, CommandClass genericEnum) {
        if (isEventMap(commandMap)) {
            result.commandClass = eventEnum;
        } else if (isTaskMap(commandMap)) {
            result.commandClass = taskEnum;
        } else {
            result.commandClass = genericEnum;
        }
    }
}
```
###### /src/lifetracker/parser/syntax/FullCommandParser.java
``` java

/**
 * This class deals with separating commands into distinct components, specified by a separator.
 */
public class FullCommandParser {

    private final Set<String> commands;
    private final String defaultCommand;

    /**
     * Creates a new {@code FullCommandParser} with a set of commands to identify. The defaultCommand provided is
     * assumed if no match is found in the set.
     *
     * @param commands       The Set of commands
     * @param defaultCommand The default command
     */
    public FullCommandParser(Set<String> commands, String defaultCommand) {
        this.commands = commands;
        this.defaultCommand = defaultCommand;
    }

    /**
     * Parses a full command.
     * <p>
     * This method determines and removes the command term from the command, then splits the remain into sections based
     * on the separator provided.
     * <p>
     * If the command cannot be determined, the default command is assumed instead.
     *
     * @param fullCommand          The full command String
     * @param fullCommandSeparator The separator for the command sections.
     * @return The list of sections, with the identified command term as the first element.
     */
    public List<String> parseFullCommand(String fullCommand, String fullCommandSeparator) {
        String newFullCommandSeparator = fullCommandSeparator;
        newFullCommandSeparator = Pattern.quote(newFullCommandSeparator);

        String[] components = fullCommand.split(newFullCommandSeparator);

        components[0] = augmentDefaultToFullCommand(components[0]);

        String command = getFirstWord(components[0]);

        //If command was split without space
        if (components[0].equals(command)) {
            components[0] = "";
        } else {
            components[0] = components[0].replaceFirst(command + " ", "");
        }

        List<String> parsedComponents = new ArrayList<>();

        parsedComponents.add(command);

        for (String component : components) {
            if (!component.trim().isEmpty()) {
                parsedComponents.add(component);
            }
        }

        return parsedComponents;

    }

    private String augmentDefaultToFullCommand(String fullCommand) {
        String command = getFirstWord(fullCommand);

        if (commands.contains(command)) {
            return fullCommand;
        } else {
            return defaultCommand + " " + fullCommand;
        }

    }

    private static String getFirstWord(String command) {

        int pos = command.indexOf(' ');

        if (pos == -1) {
            return command;
        } else {
            return command.substring(0, pos);
        }

    }

}
```
###### /src/lifetracker/parser/syntax/Parameters.java
``` java

/**
 * A data structure for storing parses parameters of a command.
 */
public class Parameters {
    public CommandClass commandClass;
    public String name;
    public LocalDateTime startDateTime;
    public LocalDateTime endDateTime;
    public Period recurringPeriod;
    public int occurLimit;
    public LocalDate dateLimit;
    public boolean isForcedOverwrite = false;
}
```
###### /src/lifetracker/parser/Parser.java
``` java

/**
 * Parser takes in a user input string which represents a command affecting the calendar, and returns a CommandObject
 * that can be executed to change the calendar.
 */
public interface Parser {
    /**
     * Parses the user input into a corresponding CommandObject.
     *
     * @param userInput The user entered command.
     * @return The CommandObject
     */
    CommandObject parse(String userInput);
}
```
###### /src/lifetracker/parser/ParserImpl.java
``` java

/**
 * An implementation of the Parser.
 * <p>
 * This ParserImpl parses commands from the user. It supports commands involving IDs, date/times, as well as durations.
 * <p>
 * The ParserImpl automatically determines the type of command to be executed by detecting the options the user has
 * provided, and creates the correct CommandObject accordingly.
 */
public class ParserImpl implements Parser {

    private static final String ERROR_INVALID_ID = "\"%1$s\" is not a valid ID!";

    private static final String ERROR_INVALID_EDIT = "Invalid syntax for edit command!";

    private static final DateTimeParser DATE_TIME_PARSER = DateTimeParser.getInstance();

    private static final DurationParser DURATION_PARSER = DurationParser.getInstance();

    private static final Map<CommandOptions, Predicate<String>> EDITONE_OPTIONS_WITH_VERIFICATIONS = new HashMap<>();

    static {
        EDITONE_OPTIONS_WITH_VERIFICATIONS.put(CommandOptions.BY, DATE_TIME_PARSER::isDateTime);
        EDITONE_OPTIONS_WITH_VERIFICATIONS.put(CommandOptions.FROM, DATE_TIME_PARSER::isDateTime);
        EDITONE_OPTIONS_WITH_VERIFICATIONS.put(CommandOptions.TO, DATE_TIME_PARSER::isDateTime);
    }

    private static final Map<CommandOptions, Predicate<String>> ADD_OPTIONS_VERIFICATIONS
            = new HashMap<>(EDITONE_OPTIONS_WITH_VERIFICATIONS);

    static {
        ADD_OPTIONS_VERIFICATIONS.put(CommandOptions.EVERY, DURATION_PARSER::isDuration);
        ADD_OPTIONS_VERIFICATIONS.put(CommandOptions.UNTIL, DATE_TIME_PARSER::isDateTime);
        ADD_OPTIONS_VERIFICATIONS.put(CommandOptions.FOR, StringUtils::isNumeric);
    }

    private static final Map<CommandOptions, Predicate<String>> EDIT_OPTIONS_VERIFICATIONS = new HashMap<>(
            ADD_OPTIONS_VERIFICATIONS);

    static {
        EDIT_OPTIONS_VERIFICATIONS.put(CommandOptions.NODUE, StringUtils::isBlank);
        EDIT_OPTIONS_VERIFICATIONS.put(CommandOptions.STOP, StringUtils::isBlank);
        EDIT_OPTIONS_VERIFICATIONS.put(CommandOptions.FOREVER, StringUtils::isBlank);
    }

    private static final Map<String, CommandOptions> KEYWORD_TO_ENUM_MAP = new HashMap<>();

    static {
        KEYWORD_TO_ENUM_MAP.put("by", CommandOptions.BY);
        KEYWORD_TO_ENUM_MAP.put("at", CommandOptions.BY);
        KEYWORD_TO_ENUM_MAP.put("from", CommandOptions.FROM);
        KEYWORD_TO_ENUM_MAP.put("to", CommandOptions.TO);
        KEYWORD_TO_ENUM_MAP.put("every", CommandOptions.EVERY);
        KEYWORD_TO_ENUM_MAP.put("until", CommandOptions.UNTIL);
        KEYWORD_TO_ENUM_MAP.put("for", CommandOptions.FOR);
        KEYWORD_TO_ENUM_MAP.put("stop", CommandOptions.STOP);
        KEYWORD_TO_ENUM_MAP.put("nodue", CommandOptions.NODUE);
        KEYWORD_TO_ENUM_MAP.put("forever", CommandOptions.FOREVER);
    }

    private static final String defaultCommand = "add";

    private static final String FULL_COMMAND_SEPARATOR = " > ";

    private final Map<String, Function<List<String>, CommandObject>> commands = new HashMap<>();

    private final FullCommandParser cmdParser;

    private final CommandFactory commandObjectFactory;

    /**
     * Creates a new {@code ParserImpl} with the specified {@code CommandFactory} as an injected dependency.
     *
     * @param commandFactory The {@code CommandFactory} dependency.
     */
    public ParserImpl(CommandFactory commandFactory) {
        populateCommand();
        cmdParser = new FullCommandParser(commands.keySet(), defaultCommand);
        commandObjectFactory = commandFactory;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject parse(String userInput) {
        List<String> commandSegments = cmdParser.parseFullCommand(userInput, FULL_COMMAND_SEPARATOR);

        String command = commandSegments.get(0).toLowerCase();
        commandSegments.remove(0);

        return commands.get(command).apply(commandSegments);
    }

    private void populateCommand() {
        commands.put("add", this::processAdd);
        commands.put("delete", this::processDelete);
        commands.put("edit", this::processEdit);
        commands.put("editone", this::processEditOne);
        commands.put("list", this::processFind);
        commands.put("find", this::processFind);
        commands.put("search", this::processFind);
        commands.put("listall", this::processFindAll);
        commands.put("findall", this::processFindAll);
        commands.put("searchall", this::processFindAll);
        commands.put("findold", this::processFindOld);
        commands.put("listold", this::processFindOld);
        commands.put("searchold", this::processFindOld);
        commands.put("today", this::processToday);
        commands.put("todayall", this::processTodayAll);
        commands.put("todayold", this::processTodayOld);
        commands.put("mark", this::processMark);
    }

    /**
     * Parses the split sections of a command identified as "add", and produces an AddCommand accordingly.
     * <p>
     * This method will further parse and analyze additional options to the command to determine the type of Add
     * command
     * the user intends.
     *
     * @param commandBody The sections of the command
     * @return The corresponding {@code AddCommand}
     * @see lifetracker.command.AddCommand
     */
    private CommandObject processAdd(List<String> commandBody) {
        String addCommandBody = restoreCommandSections(commandBody);

        CommandSectionParser<CommandOptions> bodyParser = new CommandSectionParser<>(KEYWORD_TO_ENUM_MAP,
                ADD_OPTIONS_VERIFICATIONS, CommandOptions.NAME);

        Map<CommandOptions, String> commandBodySectionsMap = bodyParser.parseCommandSection(addCommandBody);

        Parameters params = AddParameterParser.getInstance().parseCommandMap(commandBodySectionsMap);

        return processParametersForAdd(params);
    }

    private CommandObject processDelete(List<String> commandBody) {
        String idString = restoreCommandSections(commandBody);
        try {
            int id = Integer.parseInt(idString);

            return commandObjectFactory.delete(id);
        } catch (NumberFormatException ex) {
            throw new IllegalArgumentException(String.format(ERROR_INVALID_ID, idString));
        }
    }

    /**
     * Parses the split sections of a command identified as "edit", and produces the respectively CommandObject that
     * edits the calendar accordingly.
     * <p>
     * This method acts similar to the {@link #processAdd(List)} method. However, it expects a ID in the first
     * section of the command.
     *
     * @param commandBody The split command sections
     * @return The corresponding edit {@code CommandObject}
     */
    private CommandObject processEdit(List<String> commandBody) {
        if (commandBody.size() < 2) {
            throw new IllegalArgumentException(ERROR_INVALID_EDIT);
        }

        int id = getIDFromList(commandBody);

        String editCommandSection = restoreCommandSections(commandBody.subList(1, commandBody.size()));

        CommandSectionParser<CommandOptions> bodyParser = new CommandSectionParser<>(KEYWORD_TO_ENUM_MAP,
                EDIT_OPTIONS_VERIFICATIONS, CommandOptions.NAME);

        Map<CommandOptions, String> editSectionMap = bodyParser.parseCommandSection(editCommandSection);

        Parameters params = EditParameterParser.getInstance().parseCommandMap(editSectionMap);

        return processParametersForEdit(id, params);
    }

    /**
     * Parses the split sections of a command identified as "editone", and produces an {@code EditOneCommand}
     * accordingly.
     * <p>
     * This method acts similarly to {@link #processEdit(List)}, though less options are allowed.
     *
     * @param commandBody The split command sections
     * @return The corresponding {@code EditOneCommand}
     * @see lifetracker.command.EditOneCommand
     */
    private CommandObject processEditOne(List<String> commandBody) {
        if (commandBody.size() < 2) {
            throw new IllegalArgumentException(ERROR_INVALID_EDIT);
        }

        int id = getIDFromList(commandBody);
        String editCommandSection = restoreCommandSections(commandBody.subList(1, commandBody.size()));

        CommandSectionParser<CommandOptions> bodyParser = new CommandSectionParser<>(KEYWORD_TO_ENUM_MAP,
                EDITONE_OPTIONS_WITH_VERIFICATIONS, CommandOptions.NAME);

        Map<CommandOptions, String> editSectionMap = bodyParser.parseCommandSection(editCommandSection);

        Parameters params = EditOneParametersParser.getInstance().parseCommandMap(editSectionMap);

        return processParametersForEditOne(id, params);
    }

    private CommandObject processFind(List<String> commandBody) {
        String searchTerm = restoreCommandSections(commandBody).trim();

        if (searchTerm.isEmpty()) {
            return commandObjectFactory.find(false);
        } else {
            return commandObjectFactory.find(searchTerm, false);
        }
    }

    private CommandObject processFindAll(List<String> commandBody) {
        String searchTerm = restoreCommandSections(commandBody).trim();

        if (searchTerm.isEmpty()) {
            return commandObjectFactory.findAll(false);
        } else {
            return commandObjectFactory.findAll(searchTerm, false);
        }
    }

    private CommandObject processFindOld(List<String> commandBody) {
        String searchTerm = restoreCommandSections(commandBody).trim();

        if (searchTerm.isEmpty()) {
            return commandObjectFactory.findOld(false);
        } else {
            return commandObjectFactory.findOld(searchTerm, false);
        }
    }

    private CommandObject processToday(List<String> commandBody) {
        String searchTerm = restoreCommandSections(commandBody).trim();

        if (searchTerm.isEmpty()) {
            return commandObjectFactory.find(true);
        } else {
            return commandObjectFactory.find(searchTerm, false);
        }
    }

    private CommandObject processTodayOld(List<String> commandBody) {
        String searchTerm = restoreCommandSections(commandBody).trim();

        if (searchTerm.isEmpty()) {
            return commandObjectFactory.findOld(true);
        } else {
            return commandObjectFactory.findOld(searchTerm, false);
        }
    }

    private CommandObject processTodayAll(List<String> commandBody) {
        String searchTerm = restoreCommandSections(commandBody).trim();

        if (searchTerm.isEmpty()) {
            return commandObjectFactory.findAll(true);
        } else {
            return commandObjectFactory.findAll(searchTerm, false);
        }
    }

    private CommandObject processMark(List<String> commandBody) {
        String idString = restoreCommandSections(commandBody);

        try {
            int id = Integer.parseInt(idString);
            return commandObjectFactory.mark(id);
        } catch (NumberFormatException ex) {
            throw new IllegalArgumentException(String.format(ERROR_INVALID_ID, idString));
        }
    }

    /**
     * Determines the correct "add" {@code CommandObject} to create based on the {@code CommandClass} specified in the
     * given {@code Paramaters} object.
     *
     * @param params The Parameters object.
     * @return The correct "add" {@code CommandObject}
     * @see Parameters
     * @see lifetracker.parser.syntax.CommandClass
     */
    private CommandObject processParametersForAdd(Parameters params) {
        switch (params.commandClass) {
        case GENERIC :
            return commandObjectFactory.addGenericTask(params.name);
        case DEADLINE :
            return commandObjectFactory.addDeadlineTask(params.name, params.endDateTime);
        case RECURRING_TASK :
            return commandObjectFactory
                    .addRecurringDeadlineTask(params.name, params.endDateTime, params.recurringPeriod);
        case RECURRING_TASK_DATE :
            return commandObjectFactory
                    .addRecurringDeadlineTask(params.name, params.endDateTime, params.recurringPeriod,
                            params.dateLimit);
        case RECURRING_TASK_OCCURRENCES :
            return commandObjectFactory
                    .addRecurringDeadlineTask(params.name, params.endDateTime, params.recurringPeriod,
                            params.occurLimit);
        case EVENT :
            return commandObjectFactory.addEvent(params.name, params.startDateTime, params.endDateTime);
        case RECURRING_EVENT :
            return commandObjectFactory.addRecurringEvent(params.name, params.startDateTime, params.endDateTime,
                    params.recurringPeriod);
        case RECURRING_EVENT_OCCURRENCES :
            return commandObjectFactory.addRecurringEvent(params.name, params.startDateTime, params.endDateTime,
                    params.recurringPeriod, params.occurLimit);
        case RECURRING_EVENT_DATE :
            return commandObjectFactory.addRecurringEvent(params.name, params.startDateTime, params.endDateTime,
                    params.recurringPeriod, params.dateLimit);
        default :
            assert false;
            return null;
        }
    }

    /**
     * Determines the correct "edit" {@code CommandObject} to create based on the {@code CommandClass} specified in the
     * given {@code Paramaters} object.
     *
     * @param params The Parameters object.
     * @return The correct "edit" {@code CommandObject}
     * @see Parameters
     * @see lifetracker.parser.syntax.CommandClass
     */
    private CommandObject processParametersForEdit(int id, Parameters params) {
        switch (params.commandClass) {
        case GENERIC :
            return commandObjectFactory.editGenericTask(id, params.name, params.isForcedOverwrite);
        case DEADLINE :
            return commandObjectFactory
                    .editDeadline(id, params.name, params.endDateTime, params.isForcedOverwrite);
        case RECURRING_TASK :
            return commandObjectFactory
                    .editRecurringDeadline(id, params.name, params.endDateTime, params.recurringPeriod,
                            params.isForcedOverwrite);
        case RECURRING_TASK_DATE :
            return commandObjectFactory
                    .editRecurringDeadline(id, params.name, params.endDateTime, params.recurringPeriod,
                            params.dateLimit);
        case RECURRING_TASK_OCCURRENCES :
            return commandObjectFactory
                    .editRecurringDeadline(id, params.name, params.endDateTime, params.recurringPeriod,
                            params.occurLimit);
        case EVENT :
            return commandObjectFactory.editEvent(id, params.name, params.startDateTime, params.endDateTime,
                    params.isForcedOverwrite);
        case RECURRING_EVENT :
            return commandObjectFactory
                    .editRecurringEvent(id, params.name, params.startDateTime, params.endDateTime,
                            params.recurringPeriod, params.isForcedOverwrite);
        case RECURRING_EVENT_DATE :
            return commandObjectFactory
                    .editRecurringEvent(id, params.name, params.startDateTime, params.endDateTime,
                            params.recurringPeriod, params.dateLimit);
        case RECURRING_EVENT_OCCURRENCES :
            return commandObjectFactory
                    .editRecurringEvent(id, params.name, params.startDateTime, params.endDateTime,
                            params.recurringPeriod, params.occurLimit);
        case RECURRING :
            return commandObjectFactory
                    .editRecurring(id, params.name, params.recurringPeriod, params.isForcedOverwrite);
        case RECURRING_DATE :
            return commandObjectFactory.editRecurring(id, params.name, params.recurringPeriod, params.dateLimit);
        case RECURRING_OCCURRENCES :
            return commandObjectFactory.editRecurring(id, params.name, params.recurringPeriod, params.occurLimit);
        case STOP_RECURRING :
            return commandObjectFactory.editStop(id, params.name);
        default :
            assert false;
            return null;
        }
    }

    /**
     * Determines the correct "editone" {@code CommandObject} to create based on the {@code CommandClass} specified in
     * the
     * given {@code Paramaters} object.
     *
     * @param params The Parameters object.
     * @return The correct "editone" {@code CommandObject}
     * @see Parameters
     * @see lifetracker.parser.syntax.CommandClass
     */
    private CommandObject processParametersForEditOne(int id, Parameters params) {
        switch (params.commandClass) {
        case GENERIC :
            return commandObjectFactory.editOne(id, params.name);
        case DEADLINE :
            return commandObjectFactory.editOneToDeadline(id, params.name, params.endDateTime);
        case EVENT :
            return commandObjectFactory.editOneToEvent(id, params.name, params.startDateTime, params.endDateTime);
        default :
            assert false;
            return null;
        }
    }

    private int getIDFromList(List<String> stringList) {
        String idString = stringList.get(0).trim();
        int id;

        try {
            id = Integer.parseInt(idString);
        } catch (NumberFormatException ex) {
            throw new IllegalArgumentException(String.format(ERROR_INVALID_ID, idString));
        }
        return id;
    }

    private String restoreCommandSections(List<String> stringList) {

        if (stringList.isEmpty()) {
            return "";
        }

        StringBuilder collapsedString = new StringBuilder();

        for (String fragment : stringList) {
            collapsedString.append(FULL_COMMAND_SEPARATOR);

            collapsedString.append(fragment);
        }

        return collapsedString.substring(FULL_COMMAND_SEPARATOR.length());
    }
}
```
###### /src/lifetracker/command/FindAllCommand.java
``` java
public class FindAllCommand extends FindCommand {
    public FindAllCommand(boolean isOnlyToday) {
        this("", isOnlyToday);
    }

    public FindAllCommand(String searchTerm, boolean isOnlyToday) {
        super(searchTerm, isOnlyToday);
    }

    @Override
    public CalendarList execute(CalendarList calendar) {
        super.execute(calendar);

        CalendarList searchCalendar;

        if (getSearchTerm().isEmpty()) {
            searchCalendar = calendar.findAllByName("");
        } else {
            searchCalendar =  calendar.findAllByName(getSearchTerm());
        }

        if(isOnlyToday()){
            searchCalendar = searchCalendar.findToday();
        }

        return searchCalendar;
    }
}
```
###### /src/lifetracker/command/FindCommand.java
``` java
public class FindCommand extends CommandObject {

    private static final String MESSAGE_SEARCH_TERM = "Displaying entries with: \"%1$s\".";
    private static final String MESSAGE_SEARCH_ALL = "Displaying entries.";
    private static final String MESSAGE_ADDON_TODAY = " (Today's entries only)";

    private final String searchTerm;
    private final boolean isOnlyToday;

    private CalendarList originalCalendar;

    public FindCommand(boolean isOnlyToday) {
        this("", isOnlyToday);
    }

    public FindCommand(String searchTerm, boolean isOnlyToday) {
        this.isOnlyToday = isOnlyToday;
        this.searchTerm = searchTerm.trim();
    }

    @Override
    public CalendarList execute(CalendarList calendar) {
        originalCalendar = calendar;

        CalendarList searchCalendar;

        if (searchTerm.isEmpty()) {
            setComment(MESSAGE_SEARCH_ALL);
            searchCalendar = calendar;
        } else {
            setComment(String.format(MESSAGE_SEARCH_TERM, searchTerm));

            searchCalendar = calendar.findByName(searchTerm);
        }

        if (isOnlyToday) {
            searchCalendar = searchCalendar.findToday();
        }

        return searchCalendar;
    }

    @Override
    public CalendarList undo(CalendarList calendar) {
        setComment(MESSAGE_SEARCH_ALL);

        return originalCalendar;
    }

    public String getSearchTerm() {
        return searchTerm;
    }

    public boolean isOnlyToday() {
        return isOnlyToday;
    }
}
```
###### /src/lifetracker/command/CommandObject.java
``` java
public abstract class CommandObject {

    protected static final String MESSAGE_ERROR = "Error: Command was not executed.";

    private boolean executed = false;
    private Set<Integer> highlightEntries = new HashSet<>();
    private String comment = MESSAGE_ERROR;

    public CalendarList execute(CalendarList calendar) {
        assert !executed;
        executed = true;
        return calendar;
    }

    public CalendarList undo(CalendarList calendar) {
        assert executed;
        executed = false;
        return calendar;
    }

    public String getComment() {
        return comment;
    }

    public Set<Integer> getHighlightEntries() {
        return new HashSet<>(highlightEntries);
    }

    protected void setComment(String comment) {
        assert comment != null;
        this.comment = comment;
    }

    protected void addHighlightEntry(int id) {
        highlightEntries.add(id);
    }

    protected boolean isExecuted() {
        return executed;
    }

    protected void setExecuted(boolean executed) {
        this.executed = executed;
    }
}
```
###### /src/lifetracker/command/DeleteCommand.java
``` java
public class DeleteCommand extends CommandObject {

    private static final String MESSAGE_DELETED = "%1$d is deleted.";
    private static final String MESSAGE_NOT_FOUND = "%1$d cannot be found!";
    private static final String MESSAGE_UNDO = "\"%1$s\" re-added.";

    private final int entryID;
    private CalendarEntry entryDeleted;

    public DeleteCommand(int entryID) {
        this.entryID = entryID;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {

        assert calendar != null;

        entryDeleted = calendar.delete(entryID);

        if (entryDeleted == null) {
            throw new IllegalArgumentException(String.format(MESSAGE_NOT_FOUND, entryID));
        }

        setComment(String.format(MESSAGE_DELETED, entryID));

        return super.execute(calendar);
    }

    @Override
    public CalendarList undo(CalendarList calendar) {
        calendar.add(entryDeleted);

        addHighlightEntry(entryDeleted.getId());

        setComment(String.format(MESSAGE_UNDO, entryDeleted.getName()));

        return super.undo(calendar);
    }
}
```
###### /src/lifetracker/command/EditEventCommand.java
``` java
public class EditEventCommand extends EditDeadlineTaskCommand {

    protected final LocalDateTime startDateTime;

    public EditEventCommand(int id, String name, LocalDateTime startDateTime, LocalDateTime endDateTime, boolean isForcedConvert) {
        super(id, name, endDateTime, isForcedConvert);
        this.startDateTime = startDateTime;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {

        if(isForcedConvert){
            oldEntry = calendar.updateToEvent(id, name, startDateTime, endDateTime, true);
        } else{
            CalendarEntry entryToEdit = calendar.get(id);

            if(entryToEdit.isProperty(CalendarProperty.RECURRING)){
                oldEntry = calendar.updateToRecurringEvent(id, name, startDateTime, endDateTime, null, true);
            } else{
                oldEntry = calendar.updateToEvent(id, name, startDateTime, endDateTime, true);
            }
        }

        addHighlightEntry(id);

        setExecuted(true);
        setComment(String.format(MESSAGE_EDITED, id));

        return calendar;
    }
}
```
###### /src/lifetracker/command/EditOneCommand.java
``` java
public class EditOneCommand extends CommandObject {

    private static final String ERROR_NON_RECURRING = "Cannot edit single occurrence of non-recurring task!";
    private static final String MESSAGE_EDITED = "Single occurrence of \"%1$d\" edited to \"%2$d\".";
    private static final String MESSAGE_UNDO = "Single occurrence changes undone.";

    private final int id;
    private final String name;
    private final LocalDateTime start;
    private final LocalDateTime end;

    private CalendarEntry editedEntry;
    private int newEntryId;

    public EditOneCommand(int id, String name) {
        this.id = id;
        this.name = name;
        this.start = null;
        this.end = null;
    }

    public EditOneCommand(int id, String name, LocalDateTime start) {
        this.id = id;
        this.name = name;
        this.start = start;
        this.end = null;
    }

    public EditOneCommand(int id, String name, LocalDateTime start, LocalDateTime end) {
        this.id = id;
        this.name = name;
        this.start = start;
        this.end = end;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {

        if (end == null) {
            processEditName(calendar);
        } else if (start == null) {
            processEditDeadLine(calendar);
        } else {
            processEditEvent(calendar);
        }

        addHighlightEntry(id);
        addHighlightEntry(editedEntry.getId());

        setComment(String.format(MESSAGE_EDITED, id, editedEntry.getId()));

        return super.execute(calendar);
    }

    @Override
    public CalendarList undo(CalendarList calendar) {
        super.undo(calendar);

        calendar.delete(newEntryId);
        calendar.update(editedEntry);

        setComment(MESSAGE_UNDO);

        return calendar;
    }

    private void processEditName(CalendarList calendar){
        markEntry(calendar);

        calendar.updateToGeneric(newEntryId, name, false);
    }

    private void processEditDeadLine(CalendarList calendar){
        markEntry(calendar);

        calendar.updateToDeadline(newEntryId, name, end, true);
    }

    private void processEditEvent(CalendarList calendar){
        markEntry(calendar);

        calendar.updateToEvent(newEntryId, name, start, end, true);
    }

    private void markEntry(CalendarList calendar){
        OldNewEntryPair pair = calendar.mark(id);

        assert pair.oldEntry != null;

        editedEntry = pair.oldEntry;

        if(pair.newEntry == null){
            calendar.mark(id);
            throw new IllegalArgumentException(ERROR_NON_RECURRING);
        }

        newEntryId = pair.newEntry.getId();
        calendar.mark(newEntryId);


    }

}
```
###### /src/lifetracker/command/EditRecurringEventCommand.java
``` java
public class EditRecurringEventCommand extends EditRecurringTaskCommand {

    final LocalDateTime startDateTime;

    public EditRecurringEventCommand(int id, String name, LocalDateTime startDateTime, LocalDateTime endDateTime,
            Period recurringPeriod, boolean isForcedConvert) {
        super(id, name, endDateTime, recurringPeriod, isForcedConvert);
        this.startDateTime = startDateTime;
    }

    public EditRecurringEventCommand(int id, String name, LocalDateTime startDateTime, LocalDateTime endDateTime,
            Period recurringPeriod, int occurLimit) {
        super(id, name, endDateTime, recurringPeriod, occurLimit);
        this.startDateTime = startDateTime;
    }

    public EditRecurringEventCommand(int id, String name, LocalDateTime startDateTime, LocalDateTime endDateTime,
            Period recurringPeriod, LocalDate dateLimit) {
        super(id, name, endDateTime, recurringPeriod, dateLimit);
        this.startDateTime = startDateTime;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {

        if (occurLimit == OCCUR_INF) {
            oldEntry = calendar
                    .updateToRecurringEvent(id, name, startDateTime, endDateTime, recurringPeriod, !isForcedConvert);
        } else if (occurLimit == OCCUR_DATE) {
            oldEntry = calendar
                    .updateToRecurringEvent(id, name, startDateTime, endDateTime, recurringPeriod, dateLimit);
        } else {
            oldEntry = calendar
                    .updateToRecurringEvent(id, name, startDateTime, endDateTime, recurringPeriod, occurLimit);
        }

        addHighlightEntry(id);

        setExecuted(true);
        setComment(String.format(MESSAGE_EDITED, id));

        return calendar;
    }
}
```
###### /src/lifetracker/command/EditStopCommand.java
``` java
public class EditStopCommand extends EditGenericTaskCommand {

    public EditStopCommand(int id, String name) {
        super(id, name, true);
    }

    @Override
    public CalendarList execute(CalendarList calendar) {

        CalendarEntry entryToEdit = calendar.get(id);

        if (entryToEdit.getDateTime(CalendarProperty.START) == null) {
            oldEntry = calendar.updateToDeadline(id, name, null, true);
        } else {
            oldEntry = calendar.updateToEvent(id, name, null, null, true);
        }

        addHighlightEntry(id);

        setExecuted(true);
        setComment(String.format(MESSAGE_EDITED, id));

        return calendar;
    }
}
```
###### /src/lifetracker/command/MarkCommand.java
``` java
public class MarkCommand extends CommandObject {

    private static final String MESSAGE_MARKED_DONE = "\"%1$d\" marked.";
    private static final String MESSAGE_MARKED_UNDONE = "\"%1$d\" unmarked.";

    private final int entryId;

    private OldNewEntryPair markedEntryPair;

    public MarkCommand(int entryId) {
        this.entryId = entryId;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {
        markedEntryPair = calendar.mark(entryId);

        addHighlightEntry(entryId);

        setComment(String.format(MESSAGE_MARKED_DONE, entryId));

        return super.execute(calendar);
    }

    @Override
    public CalendarList undo(CalendarList calendar) {

        if(markedEntryPair.newEntry != null){
            calendar.delete(markedEntryPair.newEntry.getId());
        }

        calendar.update(markedEntryPair.oldEntry);

        setComment(String.format(MESSAGE_MARKED_UNDONE, entryId));

        return super.undo(calendar);
    }
}
```
###### /src/lifetracker/command/EditDeadlineTaskCommand.java
``` java
public class EditDeadlineTaskCommand extends EditGenericTaskCommand {

    final protected LocalDateTime endDateTime;

    public EditDeadlineTaskCommand(int id, String name, LocalDateTime endDateTime, boolean isForcedConvert) {
        super(id, name, isForcedConvert);
        this.endDateTime = endDateTime;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {
        if (isForcedConvert) {
            oldEntry = calendar.updateToDeadline(id, name, endDateTime, true);
        } else {
            CalendarEntry entryToEdit = calendar.get(id);
            if (entryToEdit.isProperty(CalendarProperty.RECURRING)) {
                oldEntry = calendar.updateToRecurringTask(id, name, endDateTime, null, true, false);
            } else {
                oldEntry = calendar.updateToDeadline(id, name, endDateTime, true);
            }
        }

        addHighlightEntry(id);

        setComment(String.format(MESSAGE_EDITED, id));
        setExecuted(true);

        return calendar;
    }
}
```
###### /src/lifetracker/command/EditGenericTaskCommand.java
``` java
public class EditGenericTaskCommand extends CommandObject {

    protected static final String MESSAGE_EDITED = "%1$s was edited.";
    protected static final String MESSAGE_UNEDITED = "Changes to %1$s were reverted.";

    protected final int id;
    protected final String name;
    protected final boolean isForcedConvert;

    protected CalendarEntry oldEntry;

    public EditGenericTaskCommand(int id, String name, boolean isForcedConvert) {
        this.id = id;
        this.name = name;
        this.isForcedConvert = isForcedConvert;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {
        oldEntry = calendar.updateToGeneric(id, name, isForcedConvert);
        addHighlightEntry(id);

        setComment(String.format(MESSAGE_EDITED, id));

        return super.execute(calendar);
    }

    @Override
    public CalendarList undo(CalendarList calendar) {
        calendar.update(oldEntry);

        setComment(String.format(MESSAGE_UNEDITED, id));

        return super.undo(calendar);
    }
}
```
###### /src/lifetracker/command/AddCommand.java
``` java
public class AddCommand extends CommandObject {

    private static final String MESSAGE_UNDO = "%1$d: \"%2$s\" removed.";
    protected static final String MESSAGE_ADDED = "\"%1$s\" is added.";

    private final String name;
    private final LocalDateTime startDateTime;
    private final LocalDateTime endDateTime;

    private int addedEntryID;

    public AddCommand(String name) {
        assert name != null;

        this.name = name;
        this.startDateTime = null;
        this.endDateTime = null;
    }

    public AddCommand(String name, LocalDateTime dueDateTime) {
        assert name != null;
        assert dueDateTime != null;

        this.name = name;
        this.startDateTime = null;
        this.endDateTime = dueDateTime;
    }

    public AddCommand(String name, LocalDateTime startDateTime, LocalDateTime endDateTime) {

        assert name != null;
        assert startDateTime != null;
        assert endDateTime != null;

        this.name = name;
        this.startDateTime = startDateTime;
        this.endDateTime = endDateTime;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {
        assert calendar != null;

        if (endDateTime == null) {
            addedEntryID = calendar.add(name);
        } else if (startDateTime == null) {
            addedEntryID = calendar.add(name, endDateTime);
        } else {
            addedEntryID = calendar.add(name, startDateTime, endDateTime);
        }

        addHighlightEntry(addedEntryID);

        setComment(String.format(MESSAGE_ADDED, name));

        return super.execute(calendar);
    }

    @Override
    public CalendarList undo(CalendarList calendar) {

        assert calendar != null;

        calendar.delete(addedEntryID);

        setComment(String.format(MESSAGE_UNDO, addedEntryID, name));

        return super.undo(calendar);
    }

    protected String getName() {
        return name;
    }

    protected LocalDateTime getStartDateTime() {
        return startDateTime;
    }

    protected LocalDateTime getEndDateTime() {
        return endDateTime;
    }

    protected void setAddedEntryID(int addedEntryID) {
        this.addedEntryID = addedEntryID;
    }
}
```
###### /src/lifetracker/command/EditRecurringTaskCommand.java
``` java
public class EditRecurringTaskCommand extends EditRecurringEntryCommand {

    protected final LocalDateTime endDateTime;

    public EditRecurringTaskCommand(int id, String name, LocalDateTime endDateTime, Period recurringPeriod,
            boolean isForcedConvert) {
        super(id, name, recurringPeriod, isForcedConvert);
        this.endDateTime = endDateTime;
    }

    public EditRecurringTaskCommand(int id, String name, LocalDateTime endDateTime, Period recurringPeriod,
            int occurLimit) {
        super(id, name, recurringPeriod, occurLimit);
        this.endDateTime = endDateTime;
    }

    public EditRecurringTaskCommand(int id, String name, LocalDateTime endDateTime, Period recurringPeriod,
            LocalDate dateLimit) {
        super(id, name, recurringPeriod, dateLimit);
        this.endDateTime = endDateTime;
    }

    @Override
    public CalendarList execute(CalendarList calendar) {
        if (occurLimit == OCCUR_INF) {
            oldEntry = calendar.updateToRecurringTask(id, name, endDateTime, recurringPeriod, !isForcedConvert, true);
        } else if (occurLimit == OCCUR_DATE) {
            oldEntry = calendar
                    .updateToRecurringTask(id, name, endDateTime, recurringPeriod, dateLimit, true);
        } else {
            oldEntry = calendar.updateToRecurringTask(id, name, endDateTime, recurringPeriod, occurLimit, true);
        }

        addHighlightEntry(id);

        setExecuted(true);
        setComment(String.format(MESSAGE_EDITED, id));
        return calendar;
    }
}
```
###### /src/lifetracker/command/CommandFactory.java
``` java

/**
 * A {@code CommandFactory} provides methods that generate {@code CommandObjects} for various purposes.
 */
public interface CommandFactory {
    /**
     * Creates a {@code CommandObject} to add an entry with only a name to the calendar.
     *
     * @param name The name of the entry
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addGenericTask(String name);

    /**
     * Creates a {@code CommandObject} to add an entry with name and a deadline to the calendar.
     *
     * @param name     The name of the entry
     * @param deadLine The deadline for the entry
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addDeadlineTask(String name, LocalDateTime deadLine);

    /**
     * Creates a {@code CommandObject} to add an entry with a name and a deadline that can recur to the calendar.
     * <p>
     * No limits will be set.
     *
     * @param name            The name of the entry
     * @param deadLine        The deadline for the entry
     * @param recurringPeriod The time between recurrences
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addRecurringDeadlineTask(String name, LocalDateTime deadLine, Period recurringPeriod);

    /**
     * Creates a {@code CommandObject} to add an entry with a name and a deadline that can recur to the calendar.
     * <p>
     * The limit is set to the number of occurrences as specified by {@code limit}.
     *
     * @param name            The name of the entry
     * @param deadLine        The deadline for the entry
     * @param recurringPeriod The time between recurrences
     * @param limit           The number of occurrences for recurrences
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addRecurringDeadlineTask(String name, LocalDateTime deadLine, Period recurringPeriod, int limit);

    /**
     * Creates a {@code CommandObject} to add an entry with a name and a deadline that can recur to the calendar.
     * <p>
     * The entry will repeat until the limitDate specified.
     *
     * @param name            The name of the entry
     * @param deadLine        The deadline for the entry
     * @param recurringPeriod The time between recurrences
     * @param limitDate       The last date for an occurrence
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addRecurringDeadlineTask(String name, LocalDateTime deadLine, Period recurringPeriod,
            LocalDate limitDate);

    /**
     * Adds an entry with a name, start date/time and end date/time to the calendar.
     *
     * @param name      The name of the entry
     * @param startTime The start date/time
     * @param endTime   The end date/time
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addEvent(String name, LocalDateTime startTime, LocalDateTime endTime);

    /**
     * Adds an entry with a name, start date/time and end date/time to the calendar, that recurs periodically.
     * <p>
     * No limit will be set for the recurrence.
     *
     * @param name            The name of the entry
     * @param startTime       The start date/time
     * @param endTime         The end date/time
     * @param recurringPeriod The time between two occurrences
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addRecurringEvent(String name, LocalDateTime startTime, LocalDateTime endTime,
            Period recurringPeriod);

    /**
     * Adds an entry with a name, start date/time and end date/time to the calendar, that recurs periodically.
     * <p>
     * The limit is set to the number of occurrences as specified by {@code limit}.
     *
     * @param name            The name of the entry
     * @param startTime       The start date/time
     * @param endTime         The end date/time
     * @param recurringPeriod The time between two occurrences
     * @param limit           The number of occurrences for recurrences
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addRecurringEvent(String name, LocalDateTime startTime, LocalDateTime endTime,
            Period recurringPeriod, int limit);

    /**
     * Adds an entry with a name, start date/time and end date/time to the calendar, that recurs periodically.
     * <p>
     * The entry will repeat until the limitDate specified.
     *
     * @param name            The name of the entry
     * @param startTime       The start date/time
     * @param endTime         The end date/time
     * @param recurringPeriod The time between two occurrences
     * @param limitDate       The last date for an occurrence
     * @return The corresponding {@code CommandObject}
     */
    CommandObject addRecurringEvent(String name, LocalDateTime startTime, LocalDateTime endTime,
            Period recurringPeriod, LocalDate limitDate);

    /**
     * Returns a CommandObject that lists all non-archived calendar entries.
     * <p>
     * This method accepts a boolean to filter out only entries for today.
     *
     * @param isOnlyToday If only entries today are to be returned.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject find(boolean isOnlyToday);

    /**
     * Returns a CommandObject that lists all non-archived calendar entries that matches the search String.
     * <p>
     * This method accepts a boolean to filter out only entries for today.
     *
     * @param searchString The search string
     * @param isOnlyToday  If only entries today are to be returned.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject find(String searchString, boolean isOnlyToday);

    /**
     * Returns a CommandObject that lists all calendar entries.
     * <p>
     * This method accepts a boolean to filter out only entries for today.
     *
     * @param isOnlyToday If only entries today are to be returned.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject findAll(boolean isOnlyToday);

    /**
     * Returns a CommandObject that lists all calendar entries that matches the search string.
     * <p>
     * This method accepts a boolean to filter out only entries for today.
     *
     * @param searchString The search String
     * @param isOnlyToday  If only entries today are to be returned.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject findAll(String searchString, boolean isOnlyToday);

    /**
     * Returns a CommandObject that lists all archived calendar entries.
     * <p>
     * This method accepts a boolean to filter out only tasks for today.
     *
     * @param isOnlyToday If only entries today are to be returned.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject findOld(boolean isOnlyToday);

    /**
     * Returns a CommandObject that lists all archived calendar entries that matches the search string.
     * <p>
     * This method accepts a boolean to filter out only entries for today.
     *
     * @param searchString The search String
     * @param isOnlyToday  If only entries today are to be returned.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject findOld(String searchString, boolean isOnlyToday);

    /**
     * Returns a CommandObject that deletes an entry based on the ID provided.
     *
     * @param id The ID of the entry to delete
     * @return The corresponding {@code CommandObject}
     */
    CommandObject delete(int id);

    /**
     * Returns a CommandObject that marks an entry based on the ID provided.
     *
     * @param id The ID of the entry to mark
     * @return The corresponding {@code CommandObject}
     */
    CommandObject mark(int id);

    /**
     * Returns a CommandObject that edits the name of a entry in the calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param isForcedConvert If the entry should be forced to only have name
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editGenericTask(int id, String name, boolean isForcedConvert);

    /**
     * Returns a CommandObject that edits the name and deadline of a entry in the calendar.
     *
     * @param id             The ID of the entry
     * @param name           The new name to change into
     * @param deadline       The new deadline
     * @param isLimitRemoved If any existing recurring limits should be removed.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editDeadline(int id, String name, LocalDateTime deadline, boolean isLimitRemoved);

    /**
     * Returns a CommandObject that edits the name, deadline and recurring period of a entry in the calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param deadline        The new deadline
     * @param recurringPeriod The new time between occurrences
     * @param isLimitRemoved  If any existing recurring limits should be removed.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurringDeadline(int id, String name, LocalDateTime deadline, Period recurringPeriod,
            boolean isLimitRemoved);

    /**
     * Returns a CommandObject that edits the name, deadline, recurring period and the recurring limit of a entry in
     * the
     * calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param deadline        The new deadline
     * @param recurringPeriod The new time between occurrences
     * @param limit           The new limit for the number of occurrences
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurringDeadline(int id, String name, LocalDateTime deadline, Period recurringPeriod, int limit);

    /**
     * Returns a CommandObject that edits the name, deadline, recurring period and the recurring limit of a entry in
     * the
     * calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param deadline        The new deadline
     * @param recurringPeriod The new time between occurrences
     * @param limitDate       The new date for the last occurrence
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurringDeadline(int id, String name, LocalDateTime deadline, Period recurringPeriod,
            LocalDate limitDate);

    /**
     * Returns a CommandObject that edits the name, start date/time and end date/time of a entry in the calendar.
     *
     * @param id             The ID of the entry
     * @param name           The new name to change into
     * @param start          The new start date/time
     * @param end            The new end date/time
     * @param isLimitRemoved If any existing recurring limits should be removed.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editEvent(int id, String name, LocalDateTime start, LocalDateTime end, boolean isLimitRemoved);

    /**
     * Returns a CommandObject that edits the name, start date/time, end date/time, and recurring period of a entry in
     * the calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param start           The new start date/time
     * @param end             The new end date/time
     * @param recurringPeriod The new time between occurrences
     * @param isLimitRemoved  If any existing recurring limits should be removed.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurringEvent(int id, String name, LocalDateTime start, LocalDateTime end,
            Period recurringPeriod, boolean isLimitRemoved);

    /**
     * Returns a CommandObject that edits the name, start date/time, end date/time, recurring period, and recurring
     * limit of a entry in
     * the calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param start           The new start date/time
     * @param end             The new end date/time
     * @param recurringPeriod The new time between occurrences
     * @param limit           The new limit for the number of occurrences
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurringEvent(int id, String name, LocalDateTime start, LocalDateTime end,
            Period recurringPeriod, int limit);

    /**
     * Returns a CommandObject that edits the name, start date/time, end date/time, recurring period, and recurring
     * limit of a entry in
     * the calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param start           The new start date/time
     * @param end             The new end date/time
     * @param recurringPeriod The new time between occurrences
     * @param limitDate       The new date for the last occurrence
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurringEvent(int id, String name, LocalDateTime start, LocalDateTime end,
            Period recurringPeriod, LocalDate limitDate);

    /**
     * Returns a CommandObject that stops the recurring entry from recurring further.
     *
     * @param id   The ID of the entry
     * @param name The new name to change into
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editStop(int id, String name);

    /**
     * Returns a CommandObject that changes the name and recurring period of an entry in the calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param recurringPeriod The new time between occurrences
     * @param isLimitRemoved  If any existing recurring limits should be removed.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurring(int id, String name, Period recurringPeriod, boolean isLimitRemoved);

    /**
     * Returns a CommandObject that changes the name, recurring period, and recurring limit of an entry in the
     * calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param recurringPeriod The new time between occurrences
     * @param limit           The new limit for the number of occurrences
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurring(int id, String name, Period recurringPeriod, int limit);

    /**
     * Returns a CommandObject that changes the name, recurring period, and recurring limit of an entry in the
     * calendar.
     *
     * @param id              The ID of the entry
     * @param name            The new name to change into
     * @param recurringPeriod The new time between occurrences
     * @param limitDate       The new last date for occurrences
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editRecurring(int id, String name, Period recurringPeriod, LocalDate limitDate);

    /**
     * Returns a {@code CommandObject} that edits an single instance of a recurring entry.
     * <p>
     * This method produces a {@code CommandObject} that changes the name of a single instance.
     *
     * @param id   The ID of the entry
     * @param name The new name of the instance
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editOne(int id, String name);

    /**
     * Returns a {@code CommandObject} that edits an single instance of a recurring entry.
     * <p>
     * This method produces a {@code CommandObject} that changes the name and deadline of a single instance.
     *
     * @param id       The ID of the entry
     * @param name     The new name of the instance
     * @param deadline The new deadline fo the instance
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editOneToDeadline(int id, String name, LocalDateTime deadline);

    /**
     * Returns a {@code CommandObject} that edits an single instance of a recurring entry.
     * <p>
     * This method produces a {@code CommandObject} that changes the name, start and end date/time of a single
     * instance.
     *
     * @param id    The ID of the entry
     * @param name  The new name of the instance
     * @param start The new start date/time the instance
     * @param end   The new end date/time for the instance.
     * @return The corresponding {@code CommandObject}
     */
    CommandObject editOneToEvent(int id, String name, LocalDateTime start, LocalDateTime end);
}
```
###### /src/lifetracker/command/CommandFactoryImpl.java
``` java

/**
 * An implementation of the {@code CommandFactory}
 *
 * @see CommandFactory
 */
public class CommandFactoryImpl implements CommandFactory {

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addGenericTask(String name) {
        return new AddCommand(name);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addDeadlineTask(String name, LocalDateTime deadLine) {
        return new AddCommand(name, deadLine);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addRecurringDeadlineTask(String name, LocalDateTime deadLine, Period recurringPeriod) {
        return new AddRecurringCommand(name, deadLine, recurringPeriod);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addRecurringDeadlineTask(String name, LocalDateTime deadLine, Period recurringPeriod,
            int limit) {
        return new AddRecurringCommand(name, deadLine, recurringPeriod, limit);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addRecurringDeadlineTask(String name, LocalDateTime deadLine, Period recurringPeriod,
            LocalDate limitDate) {
        return new AddRecurringCommand(name, deadLine, recurringPeriod, limitDate);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addEvent(String name, LocalDateTime startTime, LocalDateTime endTime) {
        return new AddCommand(name, startTime, endTime);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addRecurringEvent(String name, LocalDateTime startTime, LocalDateTime endTime,
            Period recurringPeriod) {
        return new AddRecurringCommand(name, startTime, endTime, recurringPeriod);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addRecurringEvent(String name, LocalDateTime startTime, LocalDateTime endTime,
            Period recurringPeriod, int limit) {
        return new AddRecurringCommand(name, startTime, endTime, recurringPeriod, limit);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject addRecurringEvent(String name, LocalDateTime startTime, LocalDateTime endTime,
            Period recurringPeriod, LocalDate limitDate) {
        return new AddRecurringCommand(name, startTime, endTime, recurringPeriod, limitDate);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject find(boolean isOnlyToday) {
        return new FindCommand(isOnlyToday);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject find(String searchString, boolean isOnlyToday) {
        return new FindCommand(searchString, isOnlyToday);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject findAll(boolean isOnlyToday) {
        return new FindAllCommand(isOnlyToday);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject findAll(String searchString, boolean isOnlyToday) {
        return new FindAllCommand(searchString, isOnlyToday);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject findOld(boolean isOnlyToday) {
        return new FindOldCommand(isOnlyToday);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject findOld(String searchString, boolean isOnlyToday) {
        return new FindOldCommand(searchString, isOnlyToday);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject delete(int id) {
        return new DeleteCommand(id);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject mark(int id) {
        return new MarkCommand(id);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editGenericTask(int id, String name, boolean isForcedConvert) {
        return new EditGenericTaskCommand(id, name, isForcedConvert);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editDeadline(int id, String name, LocalDateTime deadline, boolean isLimitRemoved) {
        return new EditDeadlineTaskCommand(id, name, deadline, isLimitRemoved);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurringDeadline(int id, String name, LocalDateTime deadline, Period recurringPeriod,
            boolean isLimitRemoved) {
        return new EditRecurringTaskCommand(id, name, deadline, recurringPeriod, isLimitRemoved);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurringDeadline(int id, String name, LocalDateTime deadline, Period recurringPeriod,
            int limit) {
        return new EditRecurringTaskCommand(id, name, deadline, recurringPeriod, limit);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurringDeadline(int id, String name, LocalDateTime deadline, Period recurringPeriod,
            LocalDate limitDate) {
        return new EditRecurringTaskCommand(id, name, deadline, recurringPeriod, limitDate);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editEvent(int id, String name, LocalDateTime start, LocalDateTime end,
            boolean isLimitRemoved) {
        return new EditEventCommand(id, name, start, end, isLimitRemoved);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurringEvent(int id, String name, LocalDateTime start, LocalDateTime end,
            Period recurringPeriod, boolean isLimitRemoved) {
        return new EditRecurringEventCommand(id, name, start, end, recurringPeriod, isLimitRemoved);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurringEvent(int id, String name, LocalDateTime start, LocalDateTime end,
            Period recurringPeriod, int limit) {
        return new EditRecurringEventCommand(id, name, start, end, recurringPeriod, limit);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurringEvent(int id, String name, LocalDateTime start, LocalDateTime end,
            Period recurringPeriod, LocalDate limitDate) {
        return new EditRecurringEventCommand(id, name, start, end, recurringPeriod, limitDate);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editStop(int id, String name) {
        return new EditStopCommand(id, name);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurring(int id, String name, Period recurringPeriod, boolean isLimitRemoved) {
        return new EditRecurringEntryCommand(id, name, recurringPeriod, isLimitRemoved);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurring(int id, String name, Period recurringPeriod, int limit) {
        return new EditRecurringEntryCommand(id, name, recurringPeriod, limit);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editRecurring(int id, String name, Period recurringPeriod, LocalDate limitDate) {
        return new EditRecurringEntryCommand(id, name, recurringPeriod, limitDate);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editOne(int id, String name) {
        return new EditOneCommand(id, name);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editOneToDeadline(int id, String name, LocalDateTime deadline) {
        return new EditOneCommand(id, name, deadline);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public CommandObject editOneToEvent(int id, String name, LocalDateTime start, LocalDateTime end) {
        return new EditOneCommand(id, name, start, end);
    }
}
```
###### /src/lifetracker/command/package-info.java
``` java

/**
 * The command package contains CommandObjects, created by the parser component, and executed by the logic component.
 */
package lifetracker.command;
```
###### /test/lifetracker/parser/syntax/CommandSectionParserTest.java
``` java
public class CommandSectionParserTest {

    private enum Options{
        NAME, THREE, EMPTY, EMPTY2, ANYTHING
    }

    private Map<String, Options> keywordToEnumMap =  new HashMap<>();

    private Map<Options, Predicate<String>> keyWordVerification = new HashMap<>();

    private CommandSectionParser<Options> cmdParser = new CommandSectionParser<>(keywordToEnumMap, keyWordVerification, Options.NAME);

    @Test
    public void testParseCommandBody() throws Exception {
        keywordToEnumMap.put("three", Options.THREE);
        keywordToEnumMap.put("empty", Options.EMPTY);
        keywordToEnumMap.put("empty2", Options.EMPTY2);
        keywordToEnumMap.put("anything", Options.ANYTHING);
        
        keyWordVerification.put(Options.THREE, s -> s.length() == 3);
        keyWordVerification.put(Options.EMPTY, String::isEmpty);
        keyWordVerification.put(Options.EMPTY2, String::isEmpty);
        keyWordVerification.put(Options.ANYTHING, s -> true);

        //Partition: All keyword arguments valid
        String commandBody = "name empty three abc";

        Map<Options, String> expected = new LinkedHashMap<>();

        expected.put(Options.THREE, "abc");
        expected.put(Options.EMPTY, "");
        expected.put(Options.NAME, "name");

        Assert.assertEquals(expected, cmdParser.parseCommandSection(commandBody));

        //Boundary: Blank name
        commandBody = "empty empty2";

        expected.clear();
        expected.put(Options.EMPTY2, "");
        expected.put(Options.EMPTY, "");
        expected.put(Options.NAME, "");

        Assert.assertEquals(expected, cmdParser.parseCommandSection(commandBody));

        //Partition: repeated keywords
        commandBody = "name anything abs anything abc def three abc";

        expected.clear();
        expected.put(Options.THREE, "abc");
        expected.put(Options.ANYTHING, "abc def");
        expected.put(Options.NAME, "name anything abs");

        Assert.assertEquals(expected, cmdParser.parseCommandSection(commandBody));

        //Partition: Invalid keyword arguements
        commandBody = "anything something something empty aaa";

        expected.clear();
        expected.put(Options.NAME, "anything something something empty aaa");

        Assert.assertEquals(expected, cmdParser.parseCommandSection(commandBody));
    }
}
```
###### /test/lifetracker/parser/datetime/DateTimeParserTest.java
``` java
public class DateTimeParserTest {

    @Test
    public void isDateTime() throws Exception {
        DateTimeParser parser = DateTimeParser.getInstance();

        Assert.assertTrue(parser.isDateTime("23/4/2016 2:30pm"));
        Assert.assertTrue(parser.isDateTime("23/4/2016"));
        Assert.assertTrue(parser.isDateTime("2:30pm"));
        Assert.assertTrue(parser.isDateTime("tomorrow 2pm"));
        Assert.assertTrue(parser.isDateTime("next monday 4am"));
        Assert.assertTrue(parser.isDateTime("monday after 2/3"));

        Assert.assertFalse(parser.isDateTime("abcd"));
    }

    @Test
    public void parseSingleDateTime() throws Exception {
        DateTimeParser parser = DateTimeParser.getInstance();

        LocalDateTime expected;
        LocalDateTime actual;

        //Partition: Case where everything is specified
        actual = parser.parseSingleDateTime("today 2:30pm");
        expected = LocalDateTime.of(LocalDate.now(), LocalTime.of(14, 30));
        Assert.assertEquals(expected, actual);

        //Everything is specified but in a different format
        actual = parser.parseSingleDateTime("2/3 21:33");
        expected = LocalDateTime.of(Calendar.getInstance().get(Calendar.YEAR), 3, 2, 21, 33);
        Assert.assertEquals(expected, actual);

        //Boundary case: To make sure dates don't skip to next day when it's specified explicitly.
        actual = parser.parseSingleDateTime("2/3 00:00");
        expected = LocalDateTime.of(Calendar.getInstance().get(Calendar.YEAR), 3, 2, 0, 0);
        Assert.assertEquals(expected, actual);

        //Partition: When date is not specified
        actual = parser.parseSingleDateTime("10pm");
        expected = LocalDateTime.of(LocalDate.now(), LocalTime.of(22, 0));

        //Date is supposed to skip is time specified has already passed today.
        if (expected.isBefore(LocalDateTime.now())) {
            expected = expected.plusDays(1);
        }
        Assert.assertEquals(expected, actual);

        //Boundary case: date should always skip
        actual = parser.parseSingleDateTime("00:00");
        expected = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.MIDNIGHT);
        Assert.assertEquals(expected, actual);

        //Partition: missing time
        actual = parser.parseSingleDateTime("day after tomorrow");
        expected = LocalDateTime.of(LocalDate.now().plusDays(2), LocalTime.MIDNIGHT.minusMinutes(1));
        Assert.assertEquals(expected, actual);

        //Partition: Empty string
        actual = parser.parseSingleDateTime("");
        expected = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT.minusMinutes(1));
        Assert.assertEquals(expected, actual);

    }

    @Test
    public void parseDoubleDateTime() throws Exception {

        DateTimeParser parser = DateTimeParser.getInstance();

        LocalDateTime expectedStart;
        LocalDateTime expectedEnd;

        List<LocalDateTime> expectedDateTimeList = new ArrayList<>();
        List<LocalDateTime> actualDateTimeList;

        //Parition: When everything is specified
        actualDateTimeList = parser.parseDoubleDateTime("23/3/16 11:30am", "24/3/16 11.40pm");
        expectedStart = LocalDateTime.of(2016, 3, 23, 11, 30);
        expectedEnd = LocalDateTime.of(2016, 3, 24, 23, 40);
        expectedDateTimeList.add(expectedStart);
        expectedDateTimeList.add(expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);
    }

    @Test
    public void parseDoubleDateTimeMissingEnd() throws Exception {
        DateTimeParser parser = DateTimeParser.getInstance();

        LocalDateTime expectedStart;
        LocalDateTime expectedEnd;

        List<LocalDateTime> expectedDateTimeList = new ArrayList<>();
        List<LocalDateTime> actualDateTimeList;

        //Partition: When end time is missing
        actualDateTimeList = parser.parseDoubleDateTime("23/3/16 11:30am", "24/3/16");
        expectedStart = LocalDateTime.of(2016, 3, 23, 11, 30);
        expectedEnd = LocalDateTime.of(2016, 3, 24, 11, 30);
        expectedDateTimeList.add(expectedStart);
        expectedDateTimeList.add(expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Boundary: When end date is the same
        actualDateTimeList = parser.parseDoubleDateTime("23/3/16 11:30am", "23/3/16");
        expectedEnd = LocalDateTime.of(2016, 3, 23, 12, 30);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Parition: When end date is missing
        actualDateTimeList = parser.parseDoubleDateTime("23/3/16 11:30am", "1300");
        expectedEnd = LocalDateTime.of(2016, 3, 23, 13, 0);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Boundary: When end time occurs before start time
        actualDateTimeList = parser.parseDoubleDateTime("23/3/16 11:30am", "1100");
        expectedEnd = LocalDateTime.of(2016, 3, 24, 11, 0);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Partition: When both end date and end time is missing
        actualDateTimeList = parser.parseDoubleDateTime("23/3/16 11:30am", "");
        expectedEnd = LocalDateTime.of(2016, 3, 23, 12, 30);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Boundary: When end time will spill into next day
        actualDateTimeList = parser.parseDoubleDateTime("23/3/16 11:59pm", "");
        expectedStart = LocalDateTime.of(2016, 3, 23, 23, 59);
        expectedEnd = LocalDateTime.of(2016, 3, 24, 0, 59);
        expectedDateTimeList.set(0, expectedStart);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);
    }

    @Test
    public void parseDoubleDateTimeMissingStart() throws Exception {
        DateTimeParser parser = DateTimeParser.getInstance();

        LocalDateTime expectedStart, expectedEnd;

        List<LocalDateTime> expectedDateTimeList = new ArrayList<>();
        List<LocalDateTime> actualDateTimeList;

        //Partition: When start date is missing
        actualDateTimeList = parser.parseDoubleDateTime("12am", "24/3/16 11.40pm");
        expectedStart = LocalDateTime.of(2016, 3, 24, 0, 0);
        expectedEnd = LocalDateTime.of(2016, 3, 24, 23, 40);
        expectedDateTimeList.add(expectedStart);
        expectedDateTimeList.add(expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Partition: When start time is missing
        actualDateTimeList = parser.parseDoubleDateTime("24/3/16", "24/3/16 11.40pm");
        expectedStart = LocalDateTime.of(2016, 3, 24, 22, 40);
        expectedDateTimeList.set(0, expectedStart);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Partition: Both start date and time are missing
        actualDateTimeList = parser.parseDoubleDateTime("", "24/3/16 11.40pm");
        expectedStart = LocalDateTime.of(2016, 3,24,22,40);
        expectedDateTimeList.set(0, expectedStart);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Boundary: Days crossover
        actualDateTimeList = parser.parseDoubleDateTime("", "24/3/16 12.40am");
        expectedStart = LocalDateTime.of(2016, 3,23,23,40);
        expectedDateTimeList.set(0, expectedStart);
        expectedEnd = LocalDateTime.of(2016,3,24,0,40);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);
    }

    @Test
    public void parseDoubleDateTimeMissingBoth() throws Exception {
        DateTimeParser parser = DateTimeParser.getInstance();

        LocalDateTime expectedStart, expectedEnd;

        List<LocalDateTime> expectedDateTimeList = new ArrayList<>();
        List<LocalDateTime> actualDateTimeList;

        //Partition: When both dates are missing
        actualDateTimeList = parser.parseDoubleDateTime("11:58pm", "11:59pm");
        expectedStart = LocalDateTime.of(LocalDate.now(), LocalTime.of(23, 58));
        expectedEnd = LocalDateTime.of(LocalDate.now(), LocalTime.of(23, 59));

        expectedDateTimeList.add(expectedStart);
        expectedDateTimeList.add(expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Boundary: When end time is before current time
        actualDateTimeList = parser.parseDoubleDateTime("12am", "12.01am");
        expectedStart = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(0, 0));
        expectedEnd = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(0, 1));

        expectedDateTimeList.set(0, expectedStart);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Partition: When both are blanks
        actualDateTimeList = parser.parseDoubleDateTime("", "");
        expectedStart = LocalDateTime.now().withMinute(0).withSecond(0).withNano(0).plusHours(1);
        expectedEnd = expectedStart.plusHours(1);

        expectedDateTimeList.set(0, expectedStart);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Partition: Start time and end date missing
        actualDateTimeList = parser.parseDoubleDateTime("today", "11:59pm");
        expectedEnd = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT.minusMinutes(1));
        expectedStart = expectedEnd.minusHours(1);

        expectedDateTimeList.set(0, expectedStart);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Boundary: When end time is before now
        actualDateTimeList = parser.parseDoubleDateTime("today", "12am");
        expectedEnd = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.MIDNIGHT);
        expectedStart = expectedEnd.minusHours(1);

        expectedDateTimeList.set(0, expectedStart);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Partition: Start date and end time missing
        actualDateTimeList = parser.parseDoubleDateTime("2pm", "tomorrow");
        expectedStart = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(14, 0));
        expectedEnd = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(15, 0));

        expectedDateTimeList.set(0, expectedStart);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);

        //Boundary: When start date defaults to same day as end date
        //Parser should advance time by 1 hr
        actualDateTimeList = parser.parseDoubleDateTime("2pm", "today");
        expectedStart = LocalDateTime.of(LocalDate.now(), LocalTime.of(14, 0));
        expectedEnd = LocalDateTime.of(LocalDate.now(), LocalTime.of(15, 0));

        expectedDateTimeList.set(0, expectedStart);
        expectedDateTimeList.set(1, expectedEnd);

        Assert.assertEquals(expectedDateTimeList, actualDateTimeList);
    }
}
```
###### /test/lifetracker/parser/datetime/DurationParserTest.java
``` java
public class DurationParserTest {

    private DurationParser parser = DurationParser.getInstance();

    @Test
    public void testFullParse() throws Exception {

        //Partition: Number + duration expression
        String parseString = "2 week";
        Period expectedPeriod = Period.ofWeeks(2);
        Assert.assertEquals(expectedPeriod, parser.parse(parseString));

        parseString = "10 year";
        expectedPeriod = Period.ofYears(10);
        Assert.assertEquals(expectedPeriod, parser.parse(parseString));

        parseString = "5 month";
        expectedPeriod = Period.ofMonths(5);
        Assert.assertEquals(expectedPeriod, parser.parse(parseString));

        parseString = "21 day";
        expectedPeriod = Period.ofDays(21);
        Assert.assertEquals(expectedPeriod, parser.parse(parseString));

        //Boundary: Plural expressions
        parseString = "4 weeks";
        expectedPeriod = Period.ofWeeks(4);
        Assert.assertEquals(expectedPeriod, parser.parse(parseString));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testNegativeNumbers() throws Exception {
        //Partition: when number is not valid
        parser.parse("-2 weeks");
    }

    @Test(expected = IllegalArgumentException.class)
    public void testZero() throws Exception {
        //Boundary: when number is zero
        parser.parse("0 days");
    }

    @Test(expected = IllegalArgumentException.class)
    public void testNonIntegers() throws Exception {
        //Boundary: when number is not an integer
        parser.parse("1.5 weeks");
    }

    @Test
    public void testNoNumbers() throws Exception {
        //Partition: When no numbers are provided
        String parseString = "year";
        Period expectedPeriod = Period.ofYears(1);
        Assert.assertEquals(expectedPeriod, parser.parse(parseString));

        //Boundary: Plural expressions
        parseString = "months";
        expectedPeriod = Period.ofMonths(1);
        Assert.assertEquals(expectedPeriod, parser.parse(parseString));
    }

    //Partition: Invalid inputs
    @Test(expected = IllegalArgumentException.class)
    public void testInvalidInput() throws Exception {
        parser.parse("abc");
    }

    //Boundary: Missing space
    @Test(expected = IllegalArgumentException.class)
    public void testNoSpace() throws Exception {
        parser.parse("2weeks");
    }

    //Boundary: Only invalid expression
    @Test(expected = IllegalArgumentException.class)
    public void testInvalidExpression() throws Exception {
        parser.parse("2 asd");
    }

    //Boundary: Extra words after valid command
    @Test(expected = IllegalArgumentException.class)
    public void testExtraWords() throws Exception {
        parser.parse("2 weeks abc");
    }

    //Boundary: Blank input
    @Test(expected = IllegalArgumentException.class)
    public void testBlankInput() throws Exception {
        parser.parse("");
    }

    @Test
    public void testIsValidMethod() throws Exception {

        Assert.assertTrue(parser.isDuration("2 weeks"));
        Assert.assertTrue(parser.isDuration("2 year"));
        Assert.assertTrue(parser.isDuration("month"));

        Assert.assertFalse(parser.isDuration("abc"));
        Assert.assertFalse(parser.isDuration("2 days abc"));
        Assert.assertFalse(parser.isDuration("-1 days"));
        Assert.assertFalse(parser.isDuration("1.5 months"));
        Assert.assertFalse(parser.isDuration("2years"));
        Assert.assertFalse(parser.isDuration("0 day"));
        Assert.assertFalse(parser.isDuration(""));
    }
}
```
###### /test/lifetracker/parser/ParserImplTest.java
``` java
public class ParserImplTest {

    private CommandFactory cmdFactory;
    private Parser parser;

    @Before
    public void setUp() throws Exception {
        cmdFactory = mock(CommandFactory.class);
        parser = new ParserImpl(cmdFactory);
    }

    @Test
    public void parseAddFloating() throws Exception {
        //Partition: Floating tasks
        parser.parse("add project meeting");
        verify(cmdFactory).addGenericTask("project meeting");

        //Boundary: No command
        parser.parse("water plants");
        verify(cmdFactory).addGenericTask("water plants");

        //Boundary: Name with special characters
        parser.parse("abc > < ! @ > #");
        verify(cmdFactory).addGenericTask("abc > < ! @ > #");
    }

    @Test
    public void testParseAddDeadline() throws Exception {
        //Partition: Deadline tasks
        parser.parse("add do homework by tomorrow 2pm");
        LocalDateTime expectedDateTime = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(14, 0));
        verify(cmdFactory).addDeadlineTask("do homework", expectedDateTime);
        //Various datetime formats are tested in DateTimeParserTest

        //Boundary: Invalid end date
        parser.parse("drop by supermarket");
        verify(cmdFactory).addGenericTask("drop by supermarket");

        //Boundary: 2 date times
        parser.parse("drop by 7/11 by tomorrow 2pm");
        verify(cmdFactory).addDeadlineTask("drop by 7/11", expectedDateTime);
    }

    @Test
    public void testParseAddRecurringDeadline() throws Exception {
        //Partition: Recurring deadlines
        parser.parse("finish readings by tomorrow 2pm every 2 week");
        LocalDateTime expectedDateTime = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(14, 0));
        Period expectedRecurringDuration = Period.ofWeeks(2);
        verify(cmdFactory).addRecurringDeadlineTask("finish readings", expectedDateTime, expectedRecurringDuration);

        //Boundary: Missing date time
        parser.parse("water plants every day");
        verify(cmdFactory).addRecurringDeadlineTask("water plants",
                LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT.minusMinutes(1)), Period.ofDays(1));

        //Boundary: Inverted options
        parser.parse("check out stall every 2 weeks by tomorrow 2pm");
        verify(cmdFactory).addRecurringDeadlineTask("check out stall", expectedDateTime, expectedRecurringDuration);

        //Boundary: Invalid durations
        parser.parse("check every single thing");
        verify(cmdFactory).addGenericTask("check every single thing");
    }

    @Test
    public void testParseAddEvent() throws Exception {
        //Partition: Add events
        parser.parse("CS2103 Exam from 25/4/16 1pm to 3pm");
        verify(cmdFactory)
                .addEvent("CS2103 Exam", LocalDateTime.of(2016, 4, 25, 13, 0), LocalDateTime.of(2016, 4, 25, 15, 0));

        //Boundary: Inverted options
        parser.parse("Exam to 3pm from 25/4/16 1pm");
        verify(cmdFactory).addEvent("Exam", LocalDateTime.of(2016, 4, 25, 13, 0), LocalDateTime.of(2016, 4, 25, 15, 0));

        //Boundary: Invalid date time
        parser.parse("meeting from 2pm to hello");
        verify(cmdFactory).addGenericTask("meeting from 2pm to hello");

        //Boundary: Missing to
        parser.parse("some talk from 22/4/16 10am");
        verify(cmdFactory)
                .addEvent("some talk", LocalDateTime.of(2016, 4, 22, 10, 0), LocalDateTime.of(2016, 4, 22, 11, 0));
    }

    @Test
    public void testAddRecurringEvents() throws Exception {
        //Partition: Recurring Events
        parser.parse("CS2103 Lecture from 15/1/16 4pm to 6pm every week");
        verify(cmdFactory).addRecurringEvent("CS2103 Lecture", LocalDateTime.of(2016, 1, 15, 16, 0),
                LocalDateTime.of(2016, 1, 15, 18, 0), Period.ofWeeks(1));
    }

    @Test(expected = IllegalArgumentException.class)
    public void testInvalidOptions() throws Exception {
        parser.parse("imagination from today 2pm to 3pm by tomorrow");
    }

    @Test
    public void testEdit() throws Exception {
        //Partition: Edit task
        parser.parse("edit 1 > new name from tomorrow 3pm to 4pm every 2 days");
        LocalDateTime startTime = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(15, 0));
        LocalDateTime endTime = LocalDateTime.of(LocalDate.now().plusDays(1), LocalTime.of(16, 0));

        verify(cmdFactory).editRecurringEvent(1, "new name", startTime, endTime, Period.ofDays(2), false);

        //Boundary: Missing options
        parser.parse("edit 2 > some other talk from tomorrow 3pm to 4pm");
        verify(cmdFactory).editEvent(2, "some other talk", startTime, endTime,false);

        //Boundary: Missing end date time
        parser.parse("edit 3 > run from tomorrow 3pm");
        verify(cmdFactory).editEvent(3, "run", startTime, endTime, false);

        //Boundary: Missing name
        parser.parse("edit 4 > from tomorrow 3pm to 4pm");
        verify(cmdFactory).editEvent(4, "", startTime, endTime, false);

        //Partition: Edit deadline task
        parser.parse("edit 5 > homework by tomorrow 4pm");
        verify(cmdFactory).editDeadline(5, "homework", endTime, false);

        //Boundary: Invalid deadline date time
        parser.parse("edit 6 > drop by school from home");
        verify(cmdFactory).editGenericTask(6, "drop by school from home", false);

        //Partition: Name only
        parser.parse("edit 7 > sleep");
        verify(cmdFactory).editGenericTask(7, "sleep", false);
    }

    @Test
    public void testSearch() throws Exception {
        //Partition: find all non-archived
        parser.parse("find");
        verify(cmdFactory).find(false);

        //Partition with search term
        parser.parse("search something");
        verify(cmdFactory).find("something", false);

        parser.parse("find something else");
        verify(cmdFactory).find("something else", false);

        //Boundary: with separators
        parser.parse("list something in the water > ?? > !!");
        verify(cmdFactory).find("something in the water > ?? > !!", false);
    }
}
```
###### /test/lifetracker/command/AddCommandTest.java
``` java
public class AddCommandTest {

    @Test
    public void testUnexecutedComment() throws Exception {
        AddCommand addCommand = new AddCommand("test");
        Assert.assertEquals(addCommand.getComment(), CommandObject.MESSAGE_ERROR);
    }

    @Test
    public void testExecute() throws Exception {

        //Floating task
        AddCommand addCommand = new AddCommand("floating");

        CalendarList mockedCalendar = mock(CalendarList.class);

        addCommand.execute(mockedCalendar);

        verify(mockedCalendar).add("floating");
        Assert.assertEquals("\"floating\" is added.", addCommand.getComment());

        //Deadline task
        addCommand = new AddCommand("task", LocalDateTime.MIN);

        mockedCalendar = mock(CalendarList.class);

        addCommand.execute(mockedCalendar);

        verify(mockedCalendar).add("task", LocalDateTime.MIN);
        Assert.assertEquals("\"task\" is added.", addCommand.getComment());

        //Event
        addCommand = new AddCommand("event", LocalDateTime.MIN, LocalDateTime.MAX);

        mockedCalendar = mock(CalendarList.class);

        addCommand.execute(mockedCalendar);

        verify(mockedCalendar).add("event", LocalDateTime.MIN, LocalDateTime.MAX);
        Assert.assertEquals("\"event\" is added.", addCommand.getComment());
    }

    @Test
    public void testUndo() throws Exception {

        AddCommand addCommand = new AddCommand("floating");
        CalendarList calendar = mock(CalendarList.class);
        when(calendar.add("floating")).thenReturn(1);

        addCommand.execute(calendar);
        addCommand.undo(calendar);

        verify(calendar).delete(1);
        Assert.assertEquals("1: \"floating\" removed.", addCommand.getComment());

        addCommand = new AddCommand("task", LocalDateTime.MIN);
        calendar = mock(CalendarList.class);
        when(calendar.add("task", LocalDateTime.MIN)).thenReturn(2);

        addCommand.execute(calendar);
        addCommand.undo(calendar);

        verify(calendar).delete(2);
        Assert.assertEquals("2: \"task\" removed.", addCommand.getComment());

        addCommand = new AddCommand("event", LocalDateTime.MIN, LocalDateTime.MAX);
        calendar = mock(CalendarList.class);
        when(calendar.add("event", LocalDateTime.MIN, LocalDateTime.MAX)).thenReturn(3);

        addCommand.execute(calendar);
        addCommand.undo(calendar);

        verify(calendar).delete(3);
        Assert.assertEquals("3: \"event\" removed.", addCommand.getComment());
    }

    @Test(expected = AssertionError.class)
    public void testPrematureUndo() throws Exception {
        AddCommand addCommand = new AddCommand("test");
        addCommand.undo(mock(CalendarList.class));
    }

    @Test(expected = AssertionError.class)
    public void testDoubleExecute() throws Exception {
        AddCommand addCommand = new AddCommand("test");

        CalendarList calendar = mock(CalendarList.class);

        addCommand.execute(calendar);
        addCommand.execute(calendar);
    }

    @Test(expected = AssertionError.class)
    public void testDoubleUndo() throws Exception {

        CalendarList calendar = mock(CalendarList.class);

        AddCommand addCommand = new AddCommand("test");

        addCommand.execute(calendar);

        addCommand.undo(calendar);
        addCommand.undo(calendar);
    }
}
```
###### /test/lifetracker/integration/IntegrationLogicTest.java
``` java
public class IntegrationLogicTest {

    private static final String MESSAGE_ADD = "\"%1$s\" is added.";
    private static final String MESSAGE_DELETE = "%1$d is deleted.";

    private static final String CONFIG_FILE = "config.properties";
    private static final String SAVE_FILE_PROPERTY = "savefile";

    private static final String ALT_FILENAME_EXTENSION = ".orig";

    private static final String LOG_FOLDER = "logs/";
    private static final String LOG_FILE = "lifetracker_test.log";

    private static String storageFileName;
    private Storage storage;
    private Logic logic;

    @BeforeClass
    public static void setUpTestFile() throws Exception {
        File logDir = new File(LOG_FOLDER);

        if (!logDir.exists()) {
            logDir.mkdir();
        }

        LogManager.getLogManager().reset();

        Logger globalLogger = Logger.getGlobal();
        globalLogger.addHandler(new FileHandler(LOG_FOLDER + LOG_FILE));

        File configFile = new File(CONFIG_FILE);
        if (!configFile.exists()) {
            configFile.createNewFile();
        }

        Properties properties = new Properties();
        properties.load(new BufferedInputStream(new FileInputStream(CONFIG_FILE)));
        storageFileName = properties.getProperty(SAVE_FILE_PROPERTY, "lifetracker.dat");

        File origFile = new File(storageFileName);

        if (origFile.exists()) {
            origFile.renameTo(new File(storageFileName + ALT_FILENAME_EXTENSION));
        }
    }

    @AfterClass
    public static void tearDownTestFile() throws Exception {
        File origFile = new File(storageFileName + ALT_FILENAME_EXTENSION);

        if (origFile.exists()) {
            origFile.renameTo(new File(storageFileName));
        }
    }

    @Before
    public void setUp() throws Exception {
        storage = new ThreadedFileStorage();
        logic = new LogicImpl(new ParserImpl(new CommandFactoryImpl()), storage);
    }

    @After
    public void tearDown() throws Exception {
        storage.close();
        File testFile = new File(storageFileName);
        testFile.delete();
    }

    @Test
    public void testAddFloating() throws Exception {
        ExecuteResult actual;
        ExecuteResult expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);

        //Partition: Add floating task
        actual = logic.executeCommand("add floating");
        expected.addTaskLine(1, "floating", null, false, true, null, 0, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "floating"));
        assertExecuteResult(expected, actual);

        //Boundary: no command
        actual = logic.executeCommand("free floating");

        expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);
        expected.addTaskLine(1, "floating", null, false, true, null, 0, null, false);
        expected.addTaskLine(2, "free floating", null, false, true, null, 0, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "free floating"));
        assertExecuteResult(expected, actual);

        //Boundary: reserved words
        actual = logic.executeCommand("add add");

        expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);
        expected.addTaskLine(1, "floating", null, false, true, null, 0, null, false);
        expected.addTaskLine(2, "free floating", null, false, true, null, 0, null, false);
        expected.addTaskLine(3, "add", null, false, true, null, 0, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "add"));
        assertExecuteResult(expected, actual);

        //Boundary: Empty name
        actual = logic.executeCommand("add");
        ExecuteResult error = new ExecuteResultImpl();
        error.setType(ExecuteResult.CommandType.ERROR);
        error.setComment("Invalid Command: Task/Event's name cannot be empty!");
        assertExecuteResult(error, actual);

    }

    @Test
    public void testAddDeadLine() throws Exception {
        ExecuteResult actual;
        ExecuteResult expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);

        //Partition: Add deadline tasks
        actual = logic.executeCommand("meeting by 12-5-15 3.30pm");
        LocalDateTime task1ExpectedDateTime = LocalDateTime.of(LocalDate.of(2015, 5, 12), LocalTime.of(15, 30));
        expected.addTaskLine(1, "meeting", task1ExpectedDateTime, true, true, null, 0, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "meeting"));
        assertExecuteResult(expected, actual);

        //Boundary: Missing date
        actual = logic.executeCommand("assignment by 1534");
        LocalDateTime task2ExpectedDateTime = LocalDateTime.of(LocalDate.now(), LocalTime.of(15, 34));
        if (task2ExpectedDateTime.isBefore(LocalDateTime.now())) {
            task2ExpectedDateTime = task2ExpectedDateTime.plusDays(1);
        }

        expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);
        expected.addTaskLine(1, "meeting", task1ExpectedDateTime, true, true, null, 0, null, false);
        expected.addTaskLine(2, "assignment", task2ExpectedDateTime, false, true, null, 0, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "assignment"));
        assertExecuteResult(expected, actual);

        //Boundary: Missing Time
        actual = logic.executeCommand("code review by tomorrow");
        LocalDateTime task3ExpectedDateTime = LocalDateTime
                .of(LocalDate.now().plusDays(1), LocalTime.MIDNIGHT.minusMinutes(1));

        expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);
        expected.addTaskLine(1, "meeting", task1ExpectedDateTime, true, true, null, 0, null, false);
        expected.addTaskLine(2, "assignment", task2ExpectedDateTime, false, true, null, 0, null, false);
        expected.addTaskLine(3, "code review", task3ExpectedDateTime, false, true, null, 0, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "code review"));
        assertExecuteResult(expected, actual);

        //Boundary: Invalid identifier
        actual = logic.executeCommand("meeting by boss");
        expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);
        expected.addTaskLine(1, "meeting", task1ExpectedDateTime, true, true, null, 0, null, false);
        expected.addTaskLine(2, "assignment", task2ExpectedDateTime, false, true, null, 0, null, false);
        expected.addTaskLine(3, "code review", task3ExpectedDateTime, false, true, null, 0, null, false);
        expected.addTaskLine(4, "meeting by boss", null, false, true, null, 0, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "meeting by boss"));
        assertExecuteResult(expected, actual);

        //Boundary: Missing name
        actual = logic.executeCommand("by 2pm");
        ExecuteResult error = new ExecuteResultImpl();
        error.setType(ExecuteResult.CommandType.ERROR);
        error.setComment("Invalid Command: Task/Event's name cannot be empty!");
        assertExecuteResult(error, actual);
    }

    @Test
    public void testAddRecurringDeadlineTask() throws Exception {
        ExecuteResult actual;
        ExecuteResult expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);

        //Partition: Add recurring deadline tasks
        actual = logic.executeCommand("add report by 14/1/15 2pm every 2 days");
        LocalDateTime task1ExpectedDeadline = LocalDateTime.of(LocalDate.of(2015, 1, 14), LocalTime.of(14, 0));
        expected.addTaskLine(1, "report", task1ExpectedDeadline, true, true, Period.ofDays(2), -1, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "report"));
        assertExecuteResult(expected, actual);

        //Boundary: Missing date time
        actual = logic.executeCommand("pump bicycle wheels every 2 weeks");
        LocalDateTime task2ExpectedDeadline = LocalDateTime.of(LocalDate.now(), LocalTime.MIDNIGHT.minusMinutes(1));
        expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);
        expected.addTaskLine(1, "report", task1ExpectedDeadline, true, true, Period.ofDays(2), -1, null, false);
        expected.addTaskLine(2, "pump bicycle wheels", task2ExpectedDeadline, false, true, Period.ofWeeks(2), -1, null,
                true);
        expected.setComment(String.format(MESSAGE_ADD, "pump bicycle wheels"));
        assertExecuteResult(expected, actual);

        //Boundary: Invalid recurring period identifier
        actual = logic.executeCommand("meeting every now and then");

        expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);
        expected.addTaskLine(1, "report", task1ExpectedDeadline, true, true, Period.ofDays(2), -1, null, false);
        expected.addTaskLine(2, "pump bicycle wheels", task2ExpectedDeadline, false, true, Period.ofWeeks(2), -1, null,
                false);
        expected.addTaskLine(3, "meeting every now and then", null, false, true, null, 0, null, true);
        expected.setComment(String.format(MESSAGE_ADD, "meeting every now and then"));
        assertExecuteResult(expected, actual);
    }

    @Test
    public void testAddEvents() throws Exception {
        ExecuteResult actual;
        ExecuteResult expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);

        //Partition: Add events
        actual = logic.executeCommand("add interview from 22/3/16 2.30pm to 22/3/16 4pm");
        LocalDateTime expectedStartDateTime1 = LocalDateTime.of(2016, 3, 22, 14, 30);
        LocalDateTime expectedEndDateTime1 = LocalDateTime.of(2016, 3, 22, 16, 0);
        expected.addEventLine(1, "interview", expectedStartDateTime1, expectedEndDateTime1, false, true, null, -1, null,
                false);
        expected.setComment(String.format(MESSAGE_ADD, "interview"));
        assertExecuteResult(expected, actual);
        
```
###### /test/lifetracker/integration/IntegrationLogicTest.java
``` java
    @Test
    public void testAddRecurringEvents() throws Exception {
        ExecuteResult actual;
        ExecuteResult expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);

        //Partition: Add recurring events
        actual = logic.executeCommand("add tutorial from 24/3/16 3pm to 4pm every week");
        LocalDateTime expectedStartDateTime1 = LocalDateTime.of(2016, 3, 24, 15, 0);
        LocalDateTime expectedEndDateTime1 = expectedStartDateTime1.plusHours(1);
        Period expectedRecurringPeriod1 = Period.ofWeeks(1);
        while (expectedEndDateTime1.isBefore(LocalDateTime.now())) {
            expectedStartDateTime1 = expectedStartDateTime1.plus(expectedRecurringPeriod1);
            expectedEndDateTime1 = expectedEndDateTime1.plus(expectedRecurringPeriod1);
        }
        expected.addEventLine(1, "tutorial", expectedStartDateTime1, expectedEndDateTime1, false, true,
                expectedRecurringPeriod1, 0, null, false);
        expected.setComment(String.format(MESSAGE_ADD, "tutorial"));
        assertExecuteResult(expected, actual);
        
```
###### /test/lifetracker/integration/IntegrationLogicTest.java
``` java
    @Test
    public void testDeleteEntries() throws Exception {
        ExecuteResult actual;
        ExecuteResult expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);

        logic.executeCommand("add floating task 1");
        logic.executeCommand("add floating task 2");

        //Partition: Delete existing entry
        actual = logic.executeCommand("delete 1");
        expected.addTaskLine(2, "floating task 2", null, false, true, null, 0, null, false);
        expected.setComment(String.format(MESSAGE_DELETE, 1));
        assertExecuteResult(expected, actual);

        //Boundary: Delete non-existent entry
        actual = logic.executeCommand("delete 100");
        ExecuteResult error = new ExecuteResultImpl();
        error.setType(ExecuteResult.CommandType.ERROR);
        error.setComment("Invalid Command: Entry 100 is not found!");
        assertExecuteResult(error, actual);

        //Boundary: Invalid ID
        actual = logic.executeCommand("delete");
        error.setComment("Invalid Command: \"\" is not a valid ID!");
        assertExecuteResult(error, actual);
    }

    @Test
    public void testSearch() throws Exception {
        ExecuteResult actual;
        ExecuteResult expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);

        logic.executeCommand("abcd efg");
        logic.executeCommand("xyzt");
        logic.executeCommand("xyzt from 22/3/16 2pm to 3pm");

        //Partition: keyword search
        actual = logic.executeCommand("search xyzt");
        expected.addTaskLine(2, "xyzt", null, false, true, null, 0, null, false);
        expected.addEventLine(3, "xyzt", LocalDateTime.of(2016, 3, 22, 14, 0), LocalDateTime.of(2016, 3, 22, 15, 0),
                false, false, null, 0, null, false);
        expected.setComment("Displaying entries with: \"xyzt\".");
        assertExecuteResult(expected, actual);

        //Boundary: With other keywords
        actual = logic.executeCommand("find xyzt");
        assertExecuteResult(expected, actual);

        actual = logic.executeCommand("list xyzt");
        assertExecuteResult(expected, actual);

        //Boundary: Case insensitivity
        actual = logic.executeCommand("search XYZT");
        expected.setComment("Displaying entries with: \"XYZT\".");
        assertExecuteResult(expected, actual);

        //Partition: Search all
        actual = logic.executeCommand("find");
        expected = new ExecuteResultImpl();
        expected.setType(ExecuteResult.CommandType.DISPLAY);
        expected.addTaskLine(1, "abcd efg", null, false, true, null, 0, null, false);
        expected.addTaskLine(2, "xyzt", null, false, true, null, 0, null, false);
        expected.addEventLine(3, "xyzt", LocalDateTime.of(2016, 3, 22, 14, 0), LocalDateTime.of(2016, 3, 22, 15, 0),
                false, false, null, 0, null, false);
        expected.setComment("Displaying entries.");
        assertExecuteResult(expected, actual);

        //Boundary: With other keywords
        actual = logic.executeCommand("search");
        assertExecuteResult(expected, actual);

        actual = logic.executeCommand("list");
        assertExecuteResult(expected, actual);
    }

    public void assertExecuteResult(ExecuteResult expected, ExecuteResult actual) {
        Assert.assertEquals(expected.getTaskList(), actual.getTaskList());
        Assert.assertEquals(expected.getTaskList(), actual.getTaskList());
        Assert.assertEquals(expected.getComment(), actual.getComment());
        Assert.assertEquals(expected.getType(), actual.getType());
    }
}
```
