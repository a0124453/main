# A0149467N
###### /src/lifetracker/logic/ExecuteResult.java
``` java

public interface ExecuteResult {

    /**
     * collections of command type
     */
    public enum CommandType {
        DISPLAY, SAVE, EXIT, ERROR, HELP
    }

    /**
     * @return The comment received after the execution of command.
     */
    String getComment();

    void setComment(String comment);

    /**
     * @return The updated list of tasks and events displayed in UI
     */
    List<LogicTask> getTaskList();
    
    List<LogicEvent> getEventList();

    /**
     * Adds a LogicTask object to the task list
     *
     * @param id
     *            Id of the task
     * @param name
     *            Name of the task.
     * @param deadline
     *            Deadline of the task.
     * @param isOverdue
     *            Whether the task is overdue.
     * @param isActive
     *            Whether the task is active or is done.
     * @param period
     *            Period of the task
     * @param limitOccur
     *            The occurrence limit for the recurring task
     * @param limitDate
     *            The limit date for the recurring task
     * @param isNew
     *            Whether the task is highlighted
     */
    void addTaskLine(int id, String name, LocalDateTime deadline, boolean isOverdue, boolean isActive,
            Period period, int limitOccur, LocalDate limitDate, boolean isNew);

    void addEventLine(int id, String name, LocalDateTime start, LocalDateTime end, boolean isOverdue, boolean isActive,
            Period period, int limitOccur, LocalDate limitDate, boolean isNew);

    /**
     * @return The type of the command
     */
    CommandType getType();
    
    void setType(CommandType type);
}
```
###### /src/lifetracker/logic/ExecuteResultImpl.java
``` java

public class ExecuteResultImpl implements ExecuteResult {

    //Comment received after the execution of command
    private String comment;
    
    //List of events and tasks displayed in UI
    private List<LogicEvent> eventList;
    private List<LogicTask> taskList;
    
    //Type of the command
    private CommandType commandType;

    public ExecuteResultImpl() {
        this.eventList = new ArrayList<>();
        this.taskList = new ArrayList<>();
    }

    @Override
    public String getComment() {
        return comment;
    }

    @Override
    public void setComment(String newComment) {
        assert newComment != null;

        comment = newComment;
    }

    @Override
    public List<LogicTask> getTaskList() {
        return taskList;
    }
    
    @Override
    public List<LogicEvent> getEventList() {
        return eventList;
    }

    @Override
    public void addTaskLine(int id, String name, LocalDateTime deadline, boolean isOverdue, boolean isActive,
            Period period, int limitOccur, LocalDate limitDate, boolean isNew) {
        LogicTask record = new LogicTaskImpl();
        record.setId(id);
        record.setName(name);
        record.setDeadline(deadline);
        record.setOverdue(isOverdue);
        record.setActive(isActive);
        record.setPeriod(period);
        record.setLimitOccur(limitOccur);
        record.setLimitDate(limitDate);
        record.setNew(isNew);
        taskList.add(record);
    }

    @Override
    public void addEventLine(int id, String name, LocalDateTime start, LocalDateTime end, boolean isOverdue,
            boolean isActive, Period period, int limitOccur, LocalDate limitDate, boolean isNew) {
        LogicEvent record = new LogicEventImpl();
        record.setId(id);
        record.setName(name);
        record.setStart(start);
        record.setEnd(end);
        record.setOverdue(isOverdue);
        record.setActive(isActive);
        record.setPeriod(period);
        record.setLimitOccur(limitOccur);
        record.setLimitDate(limitDate);
        record.setNew(isNew);
        eventList.add(record);
    }

    @Override
    public CommandType getType() {
        return this.commandType;
    }
    
    @Override
    public void setType(CommandType type) {
        assert type != null;
        
        this.commandType = type;
    }
}
```
###### /src/lifetracker/logic/LogicEvent.java
``` java

public interface LogicEvent {
    
    //setter and getter for each variable
    void setName(String name);
    
    String getName();
    
    void setId(int id);
    
    int getId();
    
    void setStart(LocalDateTime start);
    
    LocalDateTime getStart();
    
    void setEnd(LocalDateTime end);
    
    LocalDateTime getEnd();
    
    void setOverdue(boolean isOverdue);
    
    boolean getOverdue();
    
    void setActive(boolean isDone);
    
    boolean isDone();
    
    void setPeriod(Period period);
    
    Period getPeriod();
    
    int getLimitOccur();

    void setLimitOccur(int limitOccur);

    LocalDate getLimitDate();

    void setLimitDate(LocalDate limitDate);

    boolean isNew();

    void setNew(boolean isNew);
}
```
###### /src/lifetracker/logic/LogicEventImpl.java
``` java

public class LogicEventImpl implements LogicEvent {

    private String name; //Name of the event
    private int id; //Id of the event
    private LocalDateTime start; //Start date and time of the event
    private LocalDateTime end; //End date and time of the event
    private boolean isOverdue; //Whether the event is overdue
    private boolean isDone; //Whether the event is done
    private Period period; //Period of the event
    private int limitOccur; //The occurrence limit for the recurring event
    private LocalDate limitDate; //The limit date for the recurring event
    private boolean isNew; //Whether the event is highlighted
    
    @Override
    public void setName(String name) {
        assert name != null;
        
        this.name = name;
    }
    
    @Override
    public String getName() {
        return name;
    }
    
    @Override
    public void setId(int id) {
        assert id > 0;
        
        this.id = id;
    }
    
    @Override
    public int getId() {
        return id;
    }
    
    @Override
    public void setStart(LocalDateTime start) {
        assert start != null;
        
        this.start = start;
    }
    
    @Override
    public LocalDateTime getStart() {
        return start;
    }
    
    @Override
    public void setEnd(LocalDateTime end) {
        assert end != null;
        
        this.end = end;
    }
    
    @Override
    public LocalDateTime getEnd() {
        return end;
    }
    
    @Override
    public void setOverdue(boolean isOverdue) {
        this.isOverdue = isOverdue;
    }
    
    @Override
    public boolean getOverdue() {
        return isOverdue;
    }
    
    @Override
    public void setActive(boolean isDone) {
        this.isDone = isDone;
    }
    
    @Override
    public boolean isDone() {
        return isDone;
    }
    
    @Override
    public void setPeriod(Period period) {      
        this.period = period;   
    }
    
    @Override
    public Period getPeriod() {
        return period;
    }
    
    @Override
    public int getLimitOccur() {
        return limitOccur;
    }

    @Override
    public void setLimitOccur(int limitOccur) {
        this.limitOccur = limitOccur;
    }

    @Override
    public LocalDate getLimitDate() {
        return limitDate;
    }

    @Override
    public void setLimitDate(LocalDate limitDate) {
        this.limitDate = limitDate;
    }

    @Override
    public boolean isNew() {
        return isNew;
    }

    @Override
    public void setNew(boolean isNew) {
        this.isNew = isNew;
    }

    //Auto-generated function
    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof LogicEventImpl))
            return false;

        LogicEventImpl that = (LogicEventImpl) o;

        if (getId() != that.getId())
            return false;
        if (getOverdue() != that.getOverdue())
            return false;
        if (isDone() != that.isDone())
            return false;
        if (getLimitOccur() != that.getLimitOccur())
            return false;
        if (isNew() != that.isNew())
            return false;
        if (!getName().equals(that.getName()))
            return false;
        if (getStart() != null ? !getStart().equals(that.getStart()) : that.getStart() != null)
            return false;
        if (getEnd() != null ? !getEnd().equals(that.getEnd()) : that.getEnd() != null)
            return false;
        if (getPeriod() != null ? !getPeriod().equals(that.getPeriod()) : that.getPeriod() != null)
            return false;
        return getLimitDate() != null ? getLimitDate().equals(that.getLimitDate()) : that.getLimitDate() == null;

    }

    //Auto-generated function
    @Override
    public int hashCode() {
        int result = getName().hashCode();
        result = 31 * result + getId();
        result = 31 * result + (getStart() != null ? getStart().hashCode() : 0);
        result = 31 * result + (getEnd() != null ? getEnd().hashCode() : 0);
        result = 31 * result + (getOverdue() ? 1 : 0);
        result = 31 * result + (isDone() ? 1 : 0);
        result = 31 * result + (getPeriod() != null ? getPeriod().hashCode() : 0);
        result = 31 * result + getLimitOccur();
        result = 31 * result + (getLimitDate() != null ? getLimitDate().hashCode() : 0);
        result = 31 * result + (isNew() ? 1 : 0);
        return result;
    }
}
```
###### /src/lifetracker/logic/LogicImpl.java
``` java

public class LogicImpl implements Logic {

    //configure file constant
    private static final String CONFIG_FILE_NAME = "config.properties";
    private static final String SAVE_FILE_PROPERTY = "savefile";
    private static final String DEFAULT_SAVE_FILE_NAME = "lifetracker.dat";

    //Error message
    private static final String ERROR_INVALID_COMMAND = "Invalid Command: %1$s";
    private static final String ERROR_SAVE = "Warning: There was an error saving to the save file!";
    private static final String ERROR_ERROR_UNDO_STACK_EMPTY = "No command to undo!";
    private static final String ERROR_ERROR_REDO_STACK_EMPTY = "No command to redo!";

    //save comment
    private static final String COMMENT_SAVE = "Calendar is saved at ";

    private Parser commandParser;
    private Storage calendarStorage;
    private CalendarList calendar;

    private Stack<CommandObject> commandStack;
    private Stack<CommandObject> redoStack;

    //This is used to load and store the configuration files
    private Properties property;
    //This is the configuration file
    private File propertyFile;

    /**
    * Constructor of Logic. Initialize parser, storage and two stacks,
    *   configure the configuration file and load the calendar from storage
    * 
    * @param parser
    * @param storage
    * @throws IOException
    *       If an I/O error occurs when configuring the file or load the calendar
    */
    public LogicImpl(Parser parser, Storage storage) throws IOException {
        assert parser != null;
        assert storage != null;

        commandParser = parser;
        calendarStorage = storage;
        commandStack = new Stack<>();
        redoStack = new Stack<>();

        configureFile();

        StorageAdapter storageAdapter = new StorageAdapter(storage);
        calendar = storageAdapter.load();
    }

    /**
    * Configure the configuration file
    * 
    * @throws IOException
    *       If an I/O error occurs when createNewFile or load the fileInputStream or store the calendar
    */
    private void configureFile() throws IOException {
        property = new Properties();
        propertyFile = new File(CONFIG_FILE_NAME);

        if (!propertyFile.exists()) {
            propertyFile.createNewFile();
        }

        InputStream fileInputStream = new BufferedInputStream(new FileInputStream(propertyFile));
        property.load(fileInputStream);

        String location = property.getProperty(SAVE_FILE_PROPERTY, DEFAULT_SAVE_FILE_NAME);
        calendarStorage.setStoreAndStart(location);
    }

    /**
    * Decide what kind of command it is and set the CommandType for them,
    *   pass the command string to respective handlers
    * 
    * @param commandString
    * @return The result after execution
    */
    @Override
    public ExecuteResult executeCommand(String commandString) {
        assert commandString != null;

        String[] commandContent = commandString.split(" ");
        ExecuteResult runResult = new ExecuteResultImpl();

        if (commandContent[0].equals("saveat")) {
            runResult.setType(CommandType.SAVE);
            return processSaveat(commandString, runResult);
        }

        switch (commandString) {
            case "exit":
                runResult.setType(CommandType.EXIT);
                return runResult;
            case "help":
                runResult.setType(CommandType.HELP);
                return runResult;
            default:
                runResult.setType(CommandType.DISPLAY);
                switch (commandString) {
                    case "undo":
                        return undo(runResult);
                    case "redo":
                        return redo(runResult);
                    default:
                        return otherCommand(commandString, runResult);
                }
        }
    }

    /**
    * Save the calendar at the specified location according to the user input and set the comment.
    * 
    * @param commandString
    * @param runResult
    *       The ExecutedResult object to be modified so that it can be returned to UI
    * @return The ExecuteResult object to be returned to UI
    */
    private ExecuteResult processSaveat(String commandString, ExecuteResult runResult) {
        int position = commandString.indexOf(" ");
        String location = commandString.substring(position + 1);

        saveat(location);

        runResult.setComment(COMMENT_SAVE + location);
        return runResult;
    }

    /**
    * Save the calendar at the specified location and change the configuration file
    * 
    * @param location
    */
    private void saveat(String location) {
        try {
            calendarStorage.setStoreAndStart(location);
            property.setProperty(SAVE_FILE_PROPERTY, location);
            OutputStream fileOutputStream = new BufferedOutputStream(new FileOutputStream(propertyFile));
            property.store(fileOutputStream, "");
        } catch (IOException ex) {
            System.err.println(ERROR_SAVE);
        }
    }

    /**
    * Pop the command stack, push the command to the redo stack and undo the command.
    *   Store the changes and pass the result from parser to be processed
    *   If the command stack is empty, return an error result.
    * 
    * @param runResult
    *       The ExecutedResult object to be modified so that it can be returned to UI
    * @return The ExecuteResult object to be returned to UI
    */
    private ExecuteResult undo(ExecuteResult runResult) {
        CommandObject commandToExecute;
        CalendarList executedState;

        try {
            commandToExecute = commandStack.pop();
            redoStack.push(commandToExecute);
            executedState = commandToExecute.undo(calendar);
        } catch (EmptyStackException ex) {
            ExecuteResult errorResult = new ExecuteResultImpl();
            errorResult.setComment(String.format(ERROR_INVALID_COMMAND, ERROR_ERROR_UNDO_STACK_EMPTY));
            errorResult.setType(CommandType.ERROR);
            return errorResult;
        }

        store();
        return processExecutionResults(runResult, commandToExecute, executedState);
    }

    /**
    * Pop the redo stack, push the command to the command stack and redo the command.
    *   Store the changes and pass the result from parser to be processed
    *   If the redo stack is empty, return an error result.
    * 
    * @param runResult
    *       The ExecutedResult object to be modified so that it can be returned to UI
    * @return The ExecuteResult object to be returned to UI
    */
    private ExecuteResult redo(ExecuteResult runResult) {
        CommandObject commandToExecute;
        CalendarList executedState;

        try {
            commandToExecute = redoStack.pop();
            commandStack.push(commandToExecute);
            executedState = commandToExecute.execute(calendar);
        } catch (EmptyStackException ex) {
            ExecuteResult errorResult = new ExecuteResultImpl();
            errorResult.setComment(String.format(ERROR_INVALID_COMMAND, ERROR_ERROR_REDO_STACK_EMPTY));
            errorResult.setType(CommandType.ERROR);
            return errorResult;
        }

        store();
        return processExecutionResults(runResult, commandToExecute, executedState);
    }

    /**
    * Pass the commandString to parser and execute the command.
    *   Push the command to the command stack and clear the redo stack.
    *   Store the changes and pass the result from parser to be processed.
    *   If the command is invalid, return an error result.
    * 
    * @param commandString
    * @param runResult
    *       The ExecutedResult object to be modified so that it can be returned to UI
    * @return The ExecuteResult object to be returned to UI
    */
    private ExecuteResult otherCommand(String commandString, ExecuteResult runResult) {
        CommandObject commandToExecute;
        CalendarList executedState;

        try {
            commandToExecute = commandParser.parse(commandString);
            executedState = commandToExecute.execute(calendar);
        } catch (IllegalArgumentException ex) {
            ExecuteResult errorResult = new ExecuteResultImpl();
            errorResult.setComment(String.format(ERROR_INVALID_COMMAND, ex.getMessage()));
            errorResult.setType(CommandType.ERROR);
            return errorResult;
        }

        commandStack.push(commandToExecute);
        redoStack.clear();

        store();
        return processExecutionResults(runResult, commandToExecute, executedState);
    }

    /**
    * Store the calendar to the storage
    */
    private void store() {
        try {
            StorageAdapter storageAdapter = new StorageAdapter(calendarStorage);
            storageAdapter.store(calendar);
        } catch (IOException ex) {
            System.err.println(ERROR_SAVE);
        }
    }

    /**
    * Set the comment and for each task/event in the calendar, add task/event to the runResult
    * 
    * @param runResult
    *       The ExecutedResult object to be modified so that it can be returned to UI
    * @param commandExecuted
    *       The parser parsed the command string to a command object: commandExecuted
    * @param executedState
    *       The CalendarList to be manipulated so that it can be displayed in UI
    * @return The ExecuteResult object to be returned to UI
    */
    private ExecuteResult processExecutionResults(ExecuteResult runResult, CommandObject commandExecuted,
            CalendarList executedState) {
        assert commandExecuted != null;
        assert executedState != null;

        Set<Integer> entriesToHighlight = commandExecuted.getHighlightEntries();

        runResult.setComment(commandExecuted.getComment());

        if (!executedState.getTaskList().isEmpty()) {
            executedState.getTaskList()
                    .forEach(task -> addTask(runResult, task, entriesToHighlight.contains(task.getId())));
        }

        if (!executedState.getEventList().isEmpty()) {
            executedState.getEventList()
                    .forEach(event -> addEvent(runResult, event, entriesToHighlight.contains(event.getId())));
        }

        return runResult;
    }

    /**
    * Add the task to the runResult
    * 
    * @param runResult
    *       The ExecutedResult object to be modified so that it can be returned to UI
    * @param task
    *       The task to be added to runResult
    * @param isHighlighted
    *       Whether the task will be highlighted in UI
    */
    private void addTask(ExecuteResult runResult, CalendarEntry task, boolean isHighlighted) {
        LocalDateTime limitDate = task.getDateTime(CalendarProperty.DATE_LIMIT);
        runResult.addTaskLine(
                task.getId(),
                task.getName(),
                task.getDateTime(CalendarProperty.END),
                task.isProperty(CalendarProperty.OVER),
                task.isProperty(CalendarProperty.ACTIVE),
                task.getPeriod(),
                task.getIntegerProperty(CalendarProperty.OCCURRENCE_LIMIT),
                limitDate == null ? null : limitDate.toLocalDate(),
                isHighlighted);
    }

    /**
    * Add the event to the runResult
    * 
    * @param runResult
    *       The ExecutedResult object to be modified so that it can be returned to UI
    * @param event
    *       The event to be added to runResult
    * @param isHighlighted
    *       Whether the event will be highlighted in UI
    */
    private void addEvent(ExecuteResult runResult, CalendarEntry event, boolean isHighlighted) {
        LocalDateTime limitDate = event.getDateTime(CalendarProperty.DATE_LIMIT);
        runResult.addEventLine(
                event.getId(),
                event.getName(),
                event.getDateTime(CalendarProperty.START),
                event.getDateTime(CalendarProperty.END),
                event.isProperty(CalendarProperty.OVER),
                event.isProperty(CalendarProperty.ACTIVE),
                event.getPeriod(),
                event.getIntegerProperty(CalendarProperty.OCCURRENCE_LIMIT),
                limitDate == null ? null : limitDate.toLocalDate(),
                isHighlighted);
    }
}
```
###### /src/lifetracker/logic/LogicTask.java
``` java

public interface LogicTask {

    //setter and getter for each variable
    void setName(String name);
    
    String getName();
    
    void setId(int id);
    
    int getId();
    
    void setDeadline(LocalDateTime deadline);
    
    LocalDateTime getDeadline();
    
    void setOverdue(boolean isOverdue);
    
    boolean getOverdue();
    
    void setActive(boolean isDone);
    
    boolean isDone();
    
    void setPeriod(Period period);
    
    Period getPeriod();

    int getLimitOccur();

    void setLimitOccur(int limitOccur);

    LocalDate getLimitDate();

    void setLimitDate(LocalDate limitDate);

    boolean isNew();

    void setNew(boolean isNew);
}
```
###### /src/lifetracker/logic/LogicTaskImpl.java
``` java

public class LogicTaskImpl implements LogicTask {
    
    private String name; //Name of the task
    private int id; //Id of the task
    private LocalDateTime deadline; //Deadline of the task
    private boolean isOverdue; //Whether the task is overdue
    private boolean isDone; //Whether the task is done
    private Period period; //Period of the task
    private int limitOccur; //The occurrence limit for the recurring task
    private LocalDate limitDate; //The limit date for the recurring task
    private boolean isNew; //Whether the task is highlighted
    
    @Override
    public void setName(String name) {
        assert name != null;
        
        this.name = name;
    }
    
    @Override
    public String getName() {
        return name;
    }
    
    @Override
    public void setId(int id) {
        assert id > 0;
        
        this.id = id;
    }
    
    @Override
    public int getId() {
        return id;
    }
    
    @Override
    public void setDeadline(LocalDateTime deadline) {
        this.deadline = deadline;
    }
    
    @Override
    public LocalDateTime getDeadline() {
        return deadline;
    }
    
    @Override
    public void setOverdue(boolean isOverdue) {
        this.isOverdue = isOverdue;
    }
    
    @Override
    public boolean getOverdue() {
        return isOverdue;
    }
    
    @Override
    public void setActive(boolean isDone) {
        this.isDone = isDone;
    }
    
    @Override
    public boolean isDone() {
        return isDone;
    }
    
    @Override
    public void setPeriod(Period period) {
     this.period = period;   
    }
    
    @Override
    public Period getPeriod() {
        return period;
    }

    @Override
    public int getLimitOccur() {
        return limitOccur;
    }

    @Override
    public void setLimitOccur(int limitOccur) {
        this.limitOccur = limitOccur;
    }

    @Override
    public LocalDate getLimitDate() {
        return limitDate;
    }

    @Override
    public void setLimitDate(LocalDate limitDate) {
        this.limitDate = limitDate;
    }

    @Override
    public boolean isNew() {
        return isNew;
    }

    @Override
    public void setNew(boolean isNew) {
        this.isNew = isNew;
    }

    //Auto-generated function
    @Override
    public boolean equals(Object o) {
        if (this == o)
            return true;
        if (!(o instanceof LogicTaskImpl))
            return false;

        LogicTaskImpl logicTask = (LogicTaskImpl) o;

        if (getId() != logicTask.getId())
            return false;
        if (getOverdue() != logicTask.getOverdue())
            return false;
        if (isDone() != logicTask.isDone())
            return false;
        if (getLimitOccur() != logicTask.getLimitOccur())
            return false;
        if (isNew() != logicTask.isNew())
            return false;
        if (!getName().equals(logicTask.getName()))
            return false;
        if (getDeadline() != null ? !getDeadline().equals(logicTask.getDeadline()) : logicTask.getDeadline() != null)
            return false;
        if (getPeriod() != null ? !getPeriod().equals(logicTask.getPeriod()) : logicTask.getPeriod() != null)
            return false;
        return getLimitDate() != null ?
                getLimitDate().equals(logicTask.getLimitDate()) :
                logicTask.getLimitDate() == null;

    }

    //Auto-generated function
    @Override
    public int hashCode() {
        int result = getName().hashCode();
        result = 31 * result + getId();
        result = 31 * result + (getDeadline() != null ? getDeadline().hashCode() : 0);
        result = 31 * result + (getOverdue() ? 1 : 0);
        result = 31 * result + (isDone() ? 1 : 0);
        result = 31 * result + (getPeriod() != null ? getPeriod().hashCode() : 0);
        result = 31 * result + getLimitOccur();
        result = 31 * result + (getLimitDate() != null ? getLimitDate().hashCode() : 0);
        result = 31 * result + (isNew() ? 1 : 0);
        return result;
    }
}
```
###### /src/lifetracker/logic/StorageAdapter.java
``` java

public class StorageAdapter {

    private Storage calendarStorage;

    public StorageAdapter(Storage storage) {
        this.calendarStorage = storage;
    }

    /**
     * Convert the calendar to Json and let the storage store it
     *
     * @param calendar Calendar to be stored
     * 
     * @throws IOException
     *      If an I/O error occurs during store
     */
    public void store(CalendarList calendar) throws IOException {
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        String s = gson.toJson(calendar);
        calendarStorage.store(s);
    }

    /**
     * Load the Json string for calendar from storage and convert it to CalendarList
     *
     * @return The calendar stored in the storage
     * 
     * @throws IOException
     *      If an I/O error occurs during load()
     */
    public CalendarList load() throws IOException {
        String l = calendarStorage.load();

        if (l.isEmpty()) {
            return new CalendarListImpl();
        } else {
            Gson gson = new GsonBuilder()
                    .registerTypeHierarchyAdapter(CalendarEntry.class, new CalendarEntryImplDeserializer())
                    .setPrettyPrinting().create();
            CalendarList calendar = gson.fromJson(l, CalendarListImpl.class);
            return calendar;
        }
    }
}
```
###### /src/lifetracker/logic/Logic.java
``` java
public interface Logic {
    ExecuteResult executeCommand(String commandString);
}
```
###### /test/lifetracker/logic/LogicImplTest.java
``` java

public class LogicImplTest {

    //test command
    private static final String COMMAND_SAVE = "saveat ";
    private static final String COMMAND_EXIT = "exit";
    private static final String COMMAND_HELP = "help";
    private static final String COMMAND_ADD_FIRST = "add first meeting";
    private static final String COMMAND_ADD_SECOND = "add second meeting by 2016-12-31 23:59:59";
    private static final String COMMAND_ADD_THIRD = "add third meeting from 2017-01-01 00:00:00 to 2017-01-01 23:59:59";
    private static final String COMMAND_ERROR_MONTH1 = "add error meeting by 2016-00-31 23:59:59";
    private static final String COMMAND_ERROR_MONTH2 = "add error meeting by 2016-13-31 23:59:59";
    private static final String COMMAND_ERROR_DAY1 = "add error meeting by 2016-12-00 23:59:59";
    private static final String COMMAND_ERROR_DAY2 = "add error meeting by 2016-12-32 23:59:59";
    private static final String COMMAND_ERROR_HOUR1 = "add error meeting by 2016-12-31 -1:59:59";
    private static final String COMMAND_ERROR_HOUR2 = "add error meeting by 2016-12-31 24:59:59";
    private static final String COMMAND_ERROR_MINUTE1 = "add error meeting by 2016-12-31 23:-1:59";
    private static final String COMMAND_ERROR_MINUTE2 = "add error meeting by 2016-12-31 23:60:59";
    private static final String COMMAND_ERROR_SECOND1 = "add error meeting by 2016-12-31 23:59:-1";
    private static final String COMMAND_ERROR_SECOND2 = "add error meeting by 2016-12-31 23:59:60";
    
    //expected comment after execution
    private static final String COMMENT_SAVE = "Calendar is saved at ";
    private static final String COMMENT_ADD_FIRST = "\"first meeting\" is added.";
    private static final String COMMENT_ADD_SECOND = "\"second meeting\" is added.";
    private static final String COMMENT_ADD_THIRD = "\"third meeting\" is added.";

    //error comment after execution
    private static final String COMMENT_INVALID_COMMAND = "Invalid Command: null";
    
    //test store constant
    private static final String DEFAULT_CONFIG_FILENAME = "config.properties";
    private static final String ALT_CONFIG_FILENAME = "config.properties.orig";
    private static final String DEFAULT_TEST_STORE = "lifetracker.dat";
    private static final String ALT_TEST_STORE = "lifetracker.dat.orig";
    private static final String TEST_SAVEAT_FILE = "location";

    private static Parser parser = mock(Parser.class);
    private static Storage storage = mock(Storage.class);
    private static LogicImpl logicTest;

    private static ExecuteResult expected1 = new ExecuteResultImpl();
    private static ExecuteResult expected2 = new ExecuteResultImpl();
    private static ExecuteResult expected3 = new ExecuteResultImpl();

    private static ExecuteResult saveat = new ExecuteResultImpl();
    private static ExecuteResult exit = new ExecuteResultImpl();
    private static ExecuteResult help = new ExecuteResultImpl();
    private static ExecuteResult error = new ExecuteResultImpl();

    @BeforeClass
    public static void setUpBeforeClass() throws IOException {
        setUpStore();

        logicTest = new LogicImpl(parser, storage);

        saveat.setComment(COMMENT_SAVE + TEST_SAVEAT_FILE);
        saveat.setType(CommandType.SAVE);
        
        exit.setType(CommandType.EXIT);
        help.setType(CommandType.HELP);
        
        expected1.setComment(COMMENT_ADD_FIRST);
        expected1.setType(CommandType.DISPLAY);

        expected2.setComment(COMMENT_ADD_SECOND);
        expected2.setType(CommandType.DISPLAY);

        expected3.setComment(COMMENT_ADD_THIRD);
        expected3.setType(CommandType.DISPLAY);

        error.setComment(COMMENT_INVALID_COMMAND);
        error.setType(CommandType.ERROR);
    }

    private static void setUpStore() throws IOException {
        File origFile = new File(DEFAULT_CONFIG_FILENAME);

        if (origFile.exists()) {
            origFile.renameTo(new File(ALT_CONFIG_FILENAME));
        }

        origFile = new File(DEFAULT_TEST_STORE);

        if (origFile.exists()) {
            origFile.renameTo(new File(ALT_TEST_STORE));
        }

        when(storage.load()).thenReturn("");
    }

    @AfterClass
    public static void tearDown() {
        File testStore = new File(TEST_SAVEAT_FILE);

        if (testStore.exists()) {
            testStore.delete();
        }

        testStore = new File(DEFAULT_CONFIG_FILENAME);
        if(testStore.exists()){
            testStore.delete();
        }

        testStore = new File(DEFAULT_TEST_STORE);
        if(testStore.exists()){
            testStore.delete();
        }

        File origFile = new File(ALT_CONFIG_FILENAME);

        if (origFile.exists()) {
            origFile.renameTo(new File(DEFAULT_CONFIG_FILENAME));
        }

        origFile = new File(ALT_TEST_STORE);

        if (origFile.exists()) {
            origFile.renameTo(new File(DEFAULT_TEST_STORE));
        }

    }

    @Test
    public void testSaveat() {
        assertEquals(saveat.getComment(), logicTest.executeCommand(COMMAND_SAVE + TEST_SAVEAT_FILE).getComment());
        assertEquals(saveat.getEventList(), logicTest.executeCommand(COMMAND_SAVE + TEST_SAVEAT_FILE).getEventList());
        assertEquals(saveat.getTaskList(), logicTest.executeCommand(COMMAND_SAVE + TEST_SAVEAT_FILE).getTaskList());
        assertEquals(saveat.getType(), logicTest.executeCommand(COMMAND_SAVE + TEST_SAVEAT_FILE).getType());
    }
    
    @Test
    public void testExit() {
        assertEquals(exit.getComment(), logicTest.executeCommand(COMMAND_EXIT).getComment());
        assertEquals(exit.getEventList(), logicTest.executeCommand(COMMAND_EXIT).getEventList());
        assertEquals(exit.getTaskList(), logicTest.executeCommand(COMMAND_EXIT).getTaskList());
        assertEquals(exit.getType(), logicTest.executeCommand(COMMAND_EXIT).getType());
    }
    
    @Test
    public void testHelp() {
        assertEquals(help.getComment(), logicTest.executeCommand(COMMAND_HELP).getComment());
        assertEquals(help.getEventList(), logicTest.executeCommand(COMMAND_HELP).getEventList());
        assertEquals(help.getTaskList(), logicTest.executeCommand(COMMAND_HELP).getTaskList());
        assertEquals(help.getType(), logicTest.executeCommand(COMMAND_HELP).getType());
    }

    @Test
    public void testAddFloating() {
        AddCommand object = mock(AddCommand.class);
        CalendarList list = mock(CalendarList.class);

        when(object.getComment()).thenReturn(COMMENT_ADD_FIRST);
        when(object.execute(any(CalendarList.class))).thenReturn(list);
        when(parser.parse(COMMAND_ADD_FIRST)).thenReturn(object);

        ExecuteResult actual = logicTest.executeCommand(COMMAND_ADD_FIRST);
        verify(parser).parse(COMMAND_ADD_FIRST);

        assertEquals(expected1.getComment(), actual.getComment());
        assertEquals(expected1.getEventList(), actual.getEventList());
        assertEquals(expected1.getTaskList(), actual.getTaskList());
        assertEquals(expected1.getType(), actual.getType());
    }

    //This is the upper bound of the boundary case for the valid partition
    @Test
    public void testAddDeadline() {
        AddCommand object = mock(AddCommand.class);
        CalendarList list = mock(CalendarList.class);

        when(object.getComment()).thenReturn(COMMENT_ADD_SECOND);
        when(object.execute(any(CalendarList.class))).thenReturn(list);
        when(parser.parse(COMMAND_ADD_SECOND)).thenReturn(object);

        ExecuteResult actual = logicTest.executeCommand(COMMAND_ADD_SECOND);
        verify(parser).parse(COMMAND_ADD_SECOND);

        assertEquals(expected2.getComment(), actual.getComment());
        assertEquals(expected2.getEventList(), actual.getEventList());
        assertEquals(expected2.getTaskList(), actual.getTaskList());
        assertEquals(expected2.getType(), actual.getType());
    }

    //This is the lower bound of the boundary case for the valid partition
    @Test
    public void testAddEvent() {
        AddCommand object = mock(AddCommand.class);
        CalendarList list = mock(CalendarList.class);

        when(object.getComment()).thenReturn(COMMENT_ADD_THIRD);
        when(object.execute(any(CalendarList.class))).thenReturn(list);
        when(parser.parse(COMMAND_ADD_THIRD)).thenReturn(object);

        ExecuteResult actual = logicTest
                .executeCommand(COMMAND_ADD_THIRD);
        verify(parser).parse(COMMAND_ADD_THIRD);

        assertEquals(expected3.getComment(), actual.getComment());
        assertEquals(expected3.getEventList(), actual.getEventList());
        assertEquals(expected3.getTaskList(), actual.getTaskList());
        assertEquals(expected3.getType(), actual.getType());
    }

    //test error month
    //This is the boundary case for the invalid partition
    @Test
    public void testAddErrorMonth() {
        when(parser.parse(COMMAND_ERROR_MONTH1)).thenThrow(new IllegalArgumentException());
        when(parser.parse(COMMAND_ERROR_MONTH2)).thenThrow(new IllegalArgumentException());
        
        ExecuteResult actual1 = logicTest.executeCommand(COMMAND_ERROR_MONTH1);
        verify(parser).parse(COMMAND_ERROR_MONTH1);
        assertEquals(error.getComment(), actual1.getComment());
        assertEquals(error.getType(), actual1.getType());

        ExecuteResult actual2 = logicTest.executeCommand(COMMAND_ERROR_MONTH2);
        verify(parser).parse(COMMAND_ERROR_MONTH2);
        assertEquals(error.getComment(), actual2.getComment());
        assertEquals(error.getType(), actual2.getType());
    }
    
    //test error day
    //This is the boundary case for the invalid partition
    @Test
    public void testAddErrorDay() {
        when(parser.parse(COMMAND_ERROR_DAY1)).thenThrow(new IllegalArgumentException());
        when(parser.parse(COMMAND_ERROR_DAY2)).thenThrow(new IllegalArgumentException());
        
        ExecuteResult actual3 = logicTest.executeCommand(COMMAND_ERROR_DAY1);
        verify(parser).parse(COMMAND_ERROR_DAY1);
        assertEquals(error.getComment(), actual3.getComment());
        assertEquals(error.getType(), actual3.getType());

        ExecuteResult actual4 = logicTest.executeCommand(COMMAND_ERROR_DAY2);
        verify(parser).parse(COMMAND_ERROR_DAY2);
        assertEquals(error.getComment(), actual4.getComment());
        assertEquals(error.getType(), actual4.getType());
    }
    
    //test error hour
    //This is the boundary case for the invalid partition
    @Test
    public void testAddErrorHour() {
        when(parser.parse(COMMAND_ERROR_HOUR1)).thenThrow(new IllegalArgumentException());
        when(parser.parse(COMMAND_ERROR_HOUR2)).thenThrow(new IllegalArgumentException());

        ExecuteResult actual5 = logicTest.executeCommand(COMMAND_ERROR_HOUR1);
        verify(parser).parse(COMMAND_ERROR_HOUR1);
        assertEquals(error.getComment(), actual5.getComment());
        assertEquals(error.getType(), actual5.getType());

        ExecuteResult actual6 = logicTest.executeCommand(COMMAND_ERROR_HOUR2);
        verify(parser).parse(COMMAND_ERROR_HOUR2);
        assertEquals(error.getComment(), actual6.getComment());
        assertEquals(error.getType(), actual6.getType());
    }
    
    //test error minute
    //This is the boundary case for the invalid partition
    @Test
    public void testAddErrorMinute() {
        when(parser.parse(COMMAND_ERROR_MINUTE1)).thenThrow(new IllegalArgumentException());
        when(parser.parse(COMMAND_ERROR_MINUTE2)).thenThrow(new IllegalArgumentException());

        ExecuteResult actual7 = logicTest.executeCommand(COMMAND_ERROR_MINUTE1);
        verify(parser).parse(COMMAND_ERROR_MINUTE1);
        assertEquals(error.getComment(), actual7.getComment());
        assertEquals(error.getType(), actual7.getType());

        ExecuteResult actual8 = logicTest.executeCommand(COMMAND_ERROR_MINUTE2);
        verify(parser).parse(COMMAND_ERROR_MINUTE2);
        assertEquals(error.getComment(), actual8.getComment());
        assertEquals(error.getType(), actual8.getType());
    }
    
    //test error second
    //This is the boundary case for the invalid partition
    @Test
    public void testAddErrorSecond() {
        when(parser.parse(COMMAND_ERROR_SECOND1)).thenThrow(new IllegalArgumentException());
        when(parser.parse(COMMAND_ERROR_SECOND2)).thenThrow(new IllegalArgumentException());
        
        ExecuteResult actual9 = logicTest.executeCommand(COMMAND_ERROR_SECOND1);
        verify(parser).parse(COMMAND_ERROR_SECOND1);
        assertEquals(error.getComment(), actual9.getComment());
        assertEquals(error.getType(), actual9.getType());

        ExecuteResult actual10 = logicTest.executeCommand(COMMAND_ERROR_SECOND2);
        verify(parser).parse(COMMAND_ERROR_SECOND2);
        assertEquals(error.getComment(), actual10.getComment());
        assertEquals(error.getType(), actual10.getType());
    }
}
```
