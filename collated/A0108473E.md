# A0108473E
###### /src/lifetracker/calendar/CalendarEntry.java
``` java
/**
 * Interface implemented by all entries.
 */
public interface CalendarEntry extends VisitableEntry {

    String MESSAGE_ERROR_START_AFTER_END = "Start date/time cannot be after end date/time!";

    static void checkStartBeforeEnd(LocalDateTime start, LocalDateTime end) {
        if (start.isAfter(end)) {
            throw new IllegalArgumentException(MESSAGE_ERROR_START_AFTER_END);
        }
    }

    /**
     * Returns the unique ID number of the entry.
     * 
     * @return The unique ID number of the entry.
     */
    int getId();

    /**
     * Sets the ID number of the entry to {@code id}.
     * 
     * @param id
     *            The desired ID number to assign to the entry.
     */
    void setId(int id);

    /**
     * Returns the name of the entry.
     * 
     * @return The name of the entry.
     */
    String getName();

    /**
     * Sets the name of the entry to {@code name}.
     * 
     * @param name
     *            The desired name to assign to the entry.
     */
    void setName(String name);

    /**
     * Returns the start/end date and time of the entry depending on the
     * {@code property} provided.
     * 
     * @param property
     *            An {@code enum} representing the desired property.
     * 
     * @return A {@code LocalDateTime} property of the entry.
     */
    LocalDateTime getDateTime(CalendarProperty property);

    /**
     * Sets the start/end date and time of the entry depending on the
     * {@code property} provided.
     * 
     * @param property
     *            An {@code enum} representing the property to be modified.
     * 
     * @param dateTime
     *            The new {@code LocalDateTime} to be set.
     */
    void setDateTime(CalendarProperty property, LocalDateTime dateTime);

    /**
     * Sets the period of the (recurring) entry to {@code period}.
     * 
     * @param period
     *            The period to assign to the (recurring) entry.
     */
    void setPeriod(Period period);

    /**
     * Returns the period of the (recurring) entry.
     * 
     * @return The period of the (recurring) entry.
     */
    Period getPeriod();

    /**
     * Switches the status of an active entry to inactive, and vice versa.
     */
    void toggleActive();

    /**
     * Returns a {@code boolean} to indicate whether the entry satisfies the
     * specified property.
     * 
     * @param property
     *            An {@code enum} representing the desired property.
     * 
     * @return A {@code boolean} to indicate whether the entry satisfies the
     *         specified property.
     */
    boolean isProperty(CalendarProperty property);

    /**
     * Returns an integer property of the entry.
     * 
     * @param property
     *            An {@code enum} representing the desired property.
     * 
     * @return An integer property of the entry.
     */
    int getIntegerProperty(CalendarProperty property);

}
```
###### /src/lifetracker/calendar/CalendarList.java
``` java

/**
 * 
 * An interface for a calendar storing entries.
 * <p>
 * On top of basic {@code add} and {@code delete} methods, the interface
 * provides extensive search methods {@code findByName},
 * {@code findArchivedByName} and {@code findAllByNamex} to search for methods
 * with specified text in their descriptions. Additionally {@code findToday},
 * returns all entries occurring today.
 * <p>
 * The {@code mark} method provides a way to mark an entry as done, and uses a
 * visitor design pattern to determine the actions to be done to on entry
 * depending on its class type.
 *
 */
public interface CalendarList {

    String ERROR_INVALID_ID = "Entry %1$s is not found!";
    int BASE_ID = 0;

    /**
     * Sorts all active task objects in ascending order of deadline, and all
     * archived task objects in descending order of deadline, in two separate
     * lists. Floating tasks are at the tail end of both lists. The lists are
     * concatenated and returned as a single list.
     *
     * @return A sorted {@code List} of task objects.
     */
    List<CalendarEntry> getTaskList();

    /**
     * Sorts all active event objects in ascending order, and all archived
     * events in descending order, of end date and time followed by start date
     * and time, in two separate lists. The lists are concatenated and returned
     * as a single list.
     *
     * @return A sorted {@code List} of event objects.
     */
    List<CalendarEntry> getEventList();

    /**
     * Sorts and returns only the archived tasks in the {@code CalendarList}, in
     * descending order.
     *
     * @return A sorted {@code List} of archived task objects.
     */
    List<CalendarEntry> getArchivedTaskList();

    /**
     * Sorts and returns only the archived events in the {@code CalendarList},
     * in descending order of end date and time, followed by start date and
     * time.
     *
     * @return A sorted {@code List} of archived event objects.
     */
    List<CalendarEntry> getArchivedEventList();

    /**
     * Adds a floating task.
     *
     * @param name
     *            Name of floating task.
     * @return The entry ID of the newly added task.
     */
    int add(String name); // floating task

    /**
     * Adds a deadline task.
     *
     * @param name
     *            Name of deadline task.
     * @param deadline
     *            Deadline of said task.
     * @return The entry ID of the newly added task.
     */
    int add(String name, LocalDateTime deadline);

    /**
     * Adds a recurring deadline task that occurs periodically with an unlimited
     * number of occurrences.
     *
     * @param name
     *            Name of deadline task.
     * @param deadline
     *            Deadline of the task.
     * @param period
     *            Period between each deadline.
     * @return The entry ID of the newly added task.
     */
    int add(String name, LocalDateTime deadline, Period period);

    /**
     * Adds a recurring deadline task that occurs periodically with a limited
     * number of occurrences.
     *
     * @param name
     *            Name of deadline task.
     * @param deadline
     *            Deadline of the task.
     * @param period
     *            Period between each deadline.
     * @param limit
     *            Maximum number of occurrences of this task.
     * @return The entry ID of the newly added task.
     */
    int add(String name, LocalDateTime deadline, Period period, int limit);

    /**
     * Adds a recurring deadline task that occurs periodically up to a specified
     * date, inclusive.
     *
     * @param name
     *            Name of deadline task.
     * @param deadline
     *            Deadline of the task.
     * @param period
     *            Period between each deadline.
     * @param limitDate
     *            Date after which no more occurrences of this task will be
     *            recorded.
     * @return The entry ID of the newly added task.
     */
    int add(String name, LocalDateTime deadline, Period period, LocalDate limitDate);

    /**
     * Adds a one-time event.
     *
     * @param name
     *            Name of event.
     * @param start
     *            Start date and time of the event.
     * @param end
     *            End date and time of the event.
     * @return The entry ID of the newly added task.
     */
    int add(String name, LocalDateTime start, LocalDateTime end);

    /**
     * Adds a recurring event that occurs periodically with an unlimited number
     * of occurrences.
     *
     * @param name
     *            Name of event.
     * @param start
     *            Start date and time of the event.
     * @param end
     *            End date and time of the event.
     * @param period
     *            Period between each occurrence of this event.
     * @return The entry ID of the newly added task.
     */
    int add(String name, LocalDateTime start, LocalDateTime end, Period period);

    /**
     * Adds a recurring event that occurs periodically with a limited number of
     * occurrences.
     *
     * @param name
     *            Name of event.
     * @param start
     *            Start date and time of the event.
     * @param end
     *            End date and time of the event.
     * @param period
     *            Period between each occurrence of this event.
     * @param limit
     *            Maximum number of occurrences of this event.
     * @return The entry ID of the newly added task.
     */
    int add(String name, LocalDateTime start, LocalDateTime end, Period period, int limit);

    /**
     * Adds a recurring event that occurs periodically up to a specified
     * starting date, inclusive.
     *
     * @param name
     *            Name of event.
     * @param start
     *            Start date and time of the event.
     * @param end
     *            End date and time of the event.
     * @param period
     *            Period between each occurrence of this event.
     * @param limit
     *            Maximum number of occurrences of this event.
     * @return The entry ID of the newly added task.
     */
    int add(String name, LocalDateTime start, LocalDateTime end, Period period, LocalDate limitDate);

    /**
     * Adds an entry of any of the following types: {@code GenericEntry},
     * {@code DeadlineTask}, {@code RecurringTask}, {@code Event},
     * {@code RecurringEvent}.
     * <p>
     * If the entry does not have a valid ID number assigned to it already, it
     * will be reassigned a new one.
     * <p>
     * The entry will be added to the main or archived lists depending on
     * whether it is a task or event, and whether it is active or otherwise.
     *
     * @param entry
     *            An object of one of the five supported classes.
     * @return The entry ID of the newly added task.
     */
    int add(CalendarEntry entry);

    /**
     * Deletes an entry.
     *
     * @param id
     *            ID number of the entry to be deleted.
     * @return The entry object deleted.
     */
    CalendarEntry delete(int id);

    /**
     * Changes an entry into a {@code GenericEntry}.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * If {@code isConvertForced} is set, then this method will forcefully
     * convert the entry into a recurring task, even if information will be
     * lost. For example, if the entry was a {@code DeadlineTask}, the deadline
     * will be lost.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param isConvertForced
     *            If information can be discarded during the conversion.
     * @return The old entry object before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToGeneric(int id, String newName, boolean isConvertForced);

    /**
     * Changes an entry into a {@code DeadlineTask}.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * If {@code isConvertForced} is set, then this method will forcefully
     * convert the entry into a recurring task, even if information will be
     * lost. For example, if the entry was a {@code RecurringTask}, the
     * frequency of occurrence will be lost.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param newDeadline
     *            The new deadline to be set.
     * @param isConvertForced
     *            If information can be discarded during the conversion.
     * @return The old entry object before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToDeadline(int id, String newName, LocalDateTime newDeadline, boolean isConvertForced);

    /**
     * Changes an entry into a {@code Event}.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * If {@code isConvertForced} is set, then this method will forcefully
     * convert the entry into a recurring task, even if information will be
     * lost. For example, if the entry was a {@code RecurringEvent}, the
     * frequency of occurrence will be lost.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param newStartTime
     *            The new start date and time to be set.
     * @param newEndTime
     *            The new end date and time to be set.
     * @param isConvertForced
     *            If information can be discarded during the conversion.
     * @return The old entry object before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToEvent(int id, String newName, LocalDateTime newStartTime, LocalDateTime newEndTime,
            boolean isConvertForced);

    /**
     * Changes an entry into a {@code RecurringTask}.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * If {@code isConvertForced} is set, then this method will forcefully
     * convert the entry into a recurring task, even if information will be
     * lost. For example, if the entry was a {@code RecurringEvent}, the start
     * date and time will be lost.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param newStartTime
     *            The new start date and time to be set.
     * @param newEndTime
     *            The new end date and time to be set.
     * @param isConvertForced
     *            If information can be discarded during the conversion.
     * @return The old entry object before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToRecurringTask(int id, String newName, LocalDateTime newDeadLine, Period newPeriod,
            boolean isLimitKept, boolean isConvertForced);

    /**
     * Changes an entry into a {@code RecurringTask} with a new occurrence
     * limit.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * If {@code isConvertForced} is set, then this method will forcefully
     * convert the entry into a recurring task, even if information will be
     * lost. For example, if the entry was a {@code RecurringEvent}, the start
     * date and time will be lost.
     * <p>
     * {@code newLimit} specifies the new number of occurrences to happen after
     * and including the current occurrence. For example, if {@code newLimit} is
     * set to 4, then the task will happen 4 more times (including the current
     * iteration), no matter how many times it has occurred in the past.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param newDeadLine
     *            The new deadline.
     * @param newPeriod
     *            The new period.
     * @param newLimit
     *            The new occurrence limit.
     * @param isConvertForced
     *            If information can be discarded during the conversion.
     * @return The old entry object before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToRecurringTask(int id, String newName, LocalDateTime newDeadLine, Period newPeriod,
            int newLimit, boolean isConvertForced);

    /**
     * Changes an entry into a {@code RecurringTask} with a new limiting date.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * If {@code isConvertForced} is set, then this method will forcefully
     * convert the entry into a recurring task, even if information will be
     * lost. For example, if the entry was a {@code RecurringEvent}, the start
     * date and time will be lost.
     * <p>
     * {@code newLimitDate} specifies the new date after which the task will
     * stop recurring regardless of how many times it has occurred in the past.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param newDeadLine
     *            The new deadline.
     * @param newPeriod
     *            The new period.
     * @param newLimitDate
     *            The new limiting date.
     * @param isConvertForced
     *            If information can be discarded during the conversion.
     * @return The old entry object before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToRecurringTask(int id, String newName, LocalDateTime newDeadLine, Period newPeriod,
            LocalDate newLimitDate, boolean isConvertForced);

    /**
     * Updates an entry into a {@code RecurringEvent} without a limiting number
     * of occurrences.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * If {@code isLimitKept} is set, then this method will discard the previous
     * recurring limit set in an entry with such a limit.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param newStart
     *            The new start date and time.
     * @param newEnd
     *            The new end date and time.
     * @param newPeriod
     *            The new recurring time period.
     * @param isLimitKept
     *            If the original limit should be discarded.
     * @return The old entry before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToRecurringEvent(int id, String newName, LocalDateTime newStart, LocalDateTime newEnd,
            Period newPeriod, boolean isLimitKept);

    /**
     * Updates an entry into a {@code RecurringEvent} with a new occurrence
     * limit.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * {@code newLimit} specifies the new number of occurrences to happen after
     * and including the current occurrence. For example, if {@code newLimit} is
     * set to 4, then the event will happen 4 more times (including the current
     * iteration), no matter how many times it has occurred in the past.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param newStart
     *            The new start date and time.
     * @param newEnd
     *            The new end date and time.
     * @param newPeriod
     *            The new recurring time period.
     * @param newLimit
     *            The new occurrence limit.
     * @return The old entry before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToRecurringEvent(int id, String newName, LocalDateTime newStart, LocalDateTime newEnd,
            Period newPeriod, int newLimit);

    /**
     * Updates an entry into a {@code RecurringEvent} with a new limiting date.
     * <p>
     * Empty fields will be skipped during update, unless a conversion for the
     * entry requires it, in which case an {@code IllegalArgumentException} will
     * be thrown.
     * <p>
     * {@code newLimitDate} specifies the new limiting date after which the
     * event will not start, regardless of how many times it has occurred in the
     * past.
     *
     * @param id
     *            The ID of the entry to update.
     * @param newName
     *            The new name.
     * @param newStart
     *            The new start date and time.
     * @param newEnd
     *            The new end date and time.
     * @param newPeriod
     *            The new recurring time period.
     * @param newLimitDate
     *            The new limiting date.
     * @return The old entry before the update.
     * @throws IllegalArgumentException
     *             If fields that are required are empty.
     */
    CalendarEntry updateToRecurringEvent(int id, String newName, LocalDateTime newStart, LocalDateTime newEnd,
            Period newPeriod, LocalDate newLimitDate);

    /**
     * Overwrites an entry in the {@code CalendarList} with the new entry
     * provided, if they have the same ID.
     * <p>
     * If there are no old entries with the same ID, the new entry is simply
     * added to the CalendarList.
     *
     * @param newEntry
     *            The new entry.
     * @return The old entry before the update if present, {@code null}
     *         otherwise.
     */
    CalendarEntry update(CalendarEntry newEntry);

    /**
     * Marks an entry with ID number {@code id}. Uses a {@code MarkVisitor} to
     * mark the entry.
     *
     * @param id
     *            The ID number of the entry to be marked.
     * @return A pair of entries, one of which is the old entry before marking,
     *         and the other an updated one.
     * @see lifetracker.calendar.visitor.MarkVisitor
     */
    OldNewEntryPair mark(int id);

    /**
     * Finds and returns the {@code CalendarEntry} object with the specified ID
     * number.
     *
     * @param id
     *            ID number of desired entry.
     * @return The entry object with the specified ID number.
     * @throws IllegalArgumentException
     *             If ID number is not found.
     */
    CalendarEntry get(int id);

    /**
     * Creates and returns a copy of the {@code CalendarListImpl} object with
     * {@code taskList} and {@code eventList} filtered to contain only entries
     * with descriptions containing the desired text. Allows room for minor
     * typographical errors.
     *
     * @param toSearch
     *            The desired text to search for.
     * @return A {@code CalendarList} with customized {@code taskList} and
     *         {@code eventList}.
     */
    CalendarList findByName(String toSearch);

    /**
     * Creates and returns a {@code CalendarListImpl} object with
     * {@code taskList} and {@code eventList} set as the archived lists of the
     * main {@code CalendarList}, filtered to contain only entries with
     * descriptions containing the desired text. Allows room for minor
     * typographical errors.
     *
     * @param toSearch
     *            The desired text to search for.
     * @return A {@code CalendarList} with customized {@code taskList} and
     *         {@code eventList}.
     */
    CalendarList findArchivedByName(String toSearch);

    /**
     * Creates and returns a {@code CalendarListImpl} object with
     * {@code taskList} and {@code eventList} containing all entries (active or
     * archived) whose descriptions contain the desired text. Allows room for
     * minor typographical errors.
     *
     * @param toSearch
     *            The desired text to search for.
     * @return A {@code CalendarList} with customized {@code taskList} and
     *         {@code eventList}.
     */
    CalendarList findAllByName(String toSearch);

    /**
     * Creates and returns a {@code CalendarListImpl} object with
     * {@code taskList} and {@code eventList} containing only active tasks that
     * are due on the same day, active events that start on the same day, and
     * active events that are ongoing at the time when the method is called.
     *
     * @return A {@code CalendarList} with customized {@code taskList} and
     *         {@code eventList}.
     */
    CalendarList findToday();

}
```
###### /src/lifetracker/calendar/CalendarListImpl.java
``` java

/**
 * 
 * An implementation of the interface {@code CalendarList}. Contains lists of
 * type {@code TreeMap<Integer, CalendarEntry>} to store entries in separate
 * lists depending on whether they are tasks or events, and active or inactive.
 *
 */
public class CalendarListImpl implements CalendarList {

    private static final String ERROR_EMPTY_NAME = "Task/Event's name cannot be empty!";

    private static final double WORD_SIMILARITY_THRESHOLD_INDEX = 0.85;

    // variables
    private TreeMap<Integer, CalendarEntry> taskList = new TreeMap<>();
    private TreeMap<Integer, CalendarEntry> eventList = new TreeMap<>();
    private TreeMap<Integer, CalendarEntry> archivedTaskList = new TreeMap<>();
    private TreeMap<Integer, CalendarEntry> archivedEventList = new TreeMap<>();

    private void setTaskList(TreeMap<Integer, CalendarEntry> map) {
        this.taskList = map;
    }

    private void setEventList(TreeMap<Integer, CalendarEntry> map) {
        this.eventList = map;
    }

    @Override
    public List<CalendarEntry> getTaskList() {
        List<CalendarEntry> active = taskList.values().stream()
                .filter(entry -> entry.isProperty(CalendarProperty.ACTIVE)).collect(Collectors.toList());

        sortByDateTime(CalendarProperty.END, active);

        List<CalendarEntry> nonActive = taskList.values().stream()
                .filter(entry -> !entry.isProperty(CalendarProperty.ACTIVE)).collect(Collectors.toList());

        sortReverseByDateTime(CalendarProperty.END, nonActive);
        active.addAll(nonActive);

        return active;
    }

    @Override
    public List<CalendarEntry> getEventList() {

        List<CalendarEntry> active = eventList.values().stream()
                .filter(entry -> entry.isProperty(CalendarProperty.ACTIVE)).collect(Collectors.toList());

        sortByDateTime(CalendarProperty.END, active);
        sortByDateTime(CalendarProperty.START, active);

        List<CalendarEntry> nonActive = eventList.values().stream()
                .filter(entry -> !entry.isProperty(CalendarProperty.ACTIVE)).collect(Collectors.toList());

        sortReverseByDateTime(CalendarProperty.END, nonActive);
        sortReverseByDateTime(CalendarProperty.START, nonActive);

        active.addAll(nonActive);

        return active;
    }

    @Override
    public List<CalendarEntry> getArchivedTaskList() {
        List<CalendarEntry> list = new ArrayList<>(archivedTaskList.values());
        return sortReverseByDateTime(CalendarProperty.END, list);
    }

    @Override
    public List<CalendarEntry> getArchivedEventList() {
        List<CalendarEntry> list = new ArrayList<>(archivedEventList.values());
        List<CalendarEntry> sortedList = sortReverseByDateTime(CalendarProperty.END, list);
        sortedList = sortReverseByDateTime(CalendarProperty.START, sortedList);
        return sortedList;
    }

    @Override
    public int add(String name) {
        return add(new GenericEntry(name));
    }

    @Override
    public int add(String name, LocalDateTime deadline) {
        return add(new DeadlineTask(name, deadline));
    }

    @Override
    public int add(String name, LocalDateTime deadline, Period period) {
        return add(new RecurringTask(name, deadline, period));
    }

    @Override
    public int add(String name, LocalDateTime deadline, Period period, int limit) {
        return add(new RecurringTask(name, deadline, period, limit));
    }

    @Override
    public int add(String name, LocalDateTime deadline, Period period, LocalDate limitDate) {
        return add(new RecurringTask(name, deadline, period, limitDate));
    }

    @Override
    public int add(String name, LocalDateTime start, LocalDateTime end) {
        return add(new Event(name, start, end));
    }

    @Override
    public int add(String name, LocalDateTime start, LocalDateTime end, Period period) {
        return add(new RecurringEvent(name, start, end, period));
    }

    @Override
    public int add(String name, LocalDateTime start, LocalDateTime end, Period period, int limit) {
        return add(new RecurringEvent(name, start, end, period, limit));
    }

    @Override
    public int add(String name, LocalDateTime start, LocalDateTime end, Period period, LocalDate limitDate) {
        return add(new RecurringEvent(name, start, end, period, limitDate));
    }

    @Override
    public int add(CalendarEntry entry) {
        assert entry != null;
        assert entry.getName() != null;

        if (entry.getName().isEmpty()) {
            throw new IllegalArgumentException(ERROR_EMPTY_NAME);
        }

        if (!isValidId(entry.getId())) {
            entry.setId(getNextId());
        }
        if (entry.isProperty(CalendarProperty.ACTIVE)) {
            if (entry.getDateTime(CalendarProperty.START) == null) {
                taskList.put(entry.getId(), entry);
            } else {
                eventList.put(entry.getId(), entry);
            }
        } else {
            if (entry.getDateTime(CalendarProperty.START) == null) {
                archivedTaskList.put(entry.getId(), entry);
            } else {
                archivedEventList.put(entry.getId(), entry);
            }
        }
        return entry.getId();
    }

    @Override
    public CalendarEntry delete(int id) {
        if (taskList.containsKey(id)) {
            return taskList.remove(id);
        } else if (eventList.containsKey(id)) {
            return eventList.remove(id);
        } else if (archivedEventList.containsKey(id)) {
            return archivedEventList.remove(id);
        } else if (archivedTaskList.containsKey(id)) {
            return archivedTaskList.remove(id);
        }
        throw new IllegalArgumentException(String.format(ERROR_INVALID_ID, id));
    }

    @Override
    public CalendarEntry updateToGeneric(int id, String newName, boolean isConvertForced) {
        EntryToGenericTaskVisitor visitor = new EntryToGenericTaskVisitor(newName, isConvertForced);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry updateToDeadline(int id, String newName, LocalDateTime newDeadline, boolean isConvertForced) {
        EntryToDeadlineTaskVisitor visitor = new EntryToDeadlineTaskVisitor(newName, newDeadline, isConvertForced);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry updateToEvent(int id, String newName, LocalDateTime newStartTime, LocalDateTime newEndTime,
            boolean isConvertForced) {
        EntryToEventVisitor visitor = new EntryToEventVisitor(newName, newStartTime, newEndTime, isConvertForced);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry updateToRecurringTask(int id, String newName, LocalDateTime newDeadLine, Period newPeriod,
            boolean isLimitKept, boolean isConvertForced) {
        EntryToRecurringTaskVisitor visitor = new EntryToRecurringTaskVisitor(newName, newDeadLine, newPeriod,
                isLimitKept, isConvertForced);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry updateToRecurringTask(int id, String newName, LocalDateTime newDeadLine, Period newPeriod,
            int newLimit, boolean isConvertForced) {
        EntryToRecurringTaskVisitor visitor = new EntryToRecurringTaskVisitor(newName, newDeadLine, newPeriod, newLimit,
                isConvertForced);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry updateToRecurringTask(int id, String newName, LocalDateTime newDeadLine, Period newPeriod,
            LocalDate newLimitDate, boolean isConvertForced) {
        EntryToRecurringTaskVisitor visitor = new EntryToRecurringTaskVisitor(newName, newDeadLine, newPeriod,
                newLimitDate, isConvertForced);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry updateToRecurringEvent(int id, String newName, LocalDateTime newStart, LocalDateTime newEnd,
            Period newPeriod, boolean isLimitKept) {
        EntryToRecurringEventVisitor visitor = new EntryToRecurringEventVisitor(newName, newStart, newEnd, newPeriod,
                isLimitKept);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry updateToRecurringEvent(int id, String newName, LocalDateTime newStart, LocalDateTime newEnd,
            Period newPeriod, int newLimit) {
        EntryToRecurringEventVisitor visitor = new EntryToRecurringEventVisitor(newName, newStart, newEnd, newPeriod,
                newLimit);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry updateToRecurringEvent(int id, String newName, LocalDateTime newStart, LocalDateTime newEnd,
            Period newPeriod, LocalDate newLimit) {
        EntryToRecurringEventVisitor visitor = new EntryToRecurringEventVisitor(newName, newStart, newEnd, newPeriod,
                newLimit);
        return updateWithVisitor(visitor, id);
    }

    @Override
    public CalendarEntry update(CalendarEntry newEntry) {
        CalendarEntry oldEntry = null;
        if (isPresent(newEntry.getId())) {
            oldEntry = delete(newEntry.getId());
        }

        add(newEntry);

        return oldEntry;
    }

    @Override
    public OldNewEntryPair mark(int id) {
        CalendarEntry entryToMark = delete(id);

        MarkVisitor visitor = new MarkVisitor();
        OldNewEntryPair pair = entryToMark.accept(visitor);

        add(entryToMark);

        if (pair.newEntry != null) {
            update(pair.newEntry);
        }

        return pair;
    }

    @Override
    public CalendarEntry get(int id) {
        if (taskList.containsKey(id)) {
            return taskList.get(id);
        } else if (eventList.containsKey(id)) {
            return eventList.get(id);
        } else if (archivedEventList.containsKey(id)) {
            return archivedEventList.get(id);
        } else if (archivedTaskList.containsKey(id)) {
            return archivedTaskList.get(id);
        }
        throw new IllegalArgumentException(String.format(ERROR_INVALID_ID, id));
    }

    @Override
    public CalendarList findByName(String toSearch) {
        CalendarListImpl result = new CalendarListImpl();
        TreeMap<Integer, CalendarEntry> copyTaskList = new TreeMap<>();
        copyTaskList.putAll(this.taskList);
        filterByName(copyTaskList, toSearch);
        TreeMap<Integer, CalendarEntry> copyEventList = new TreeMap<>();
        copyEventList.putAll(this.eventList);
        filterByName(copyEventList, toSearch);
        result.setTaskList(copyTaskList);
        result.setEventList(copyEventList);
        return result;
    }

    @Override
    public CalendarList findArchivedByName(String toSearch) {
        CalendarListImpl result = new CalendarListImpl();
        result.setTaskList(this.archivedTaskList);
        result.setEventList(this.archivedEventList);
        return result.findByName(toSearch);
    }

    @Override
    public CalendarList findAllByName(String toSearch) {
        CalendarListImpl result = new CalendarListImpl();

        TreeMap<Integer, CalendarEntry> combinedTask = new TreeMap<>(taskList);
        combinedTask.putAll(archivedTaskList);
        result.setTaskList(combinedTask);

        TreeMap<Integer, CalendarEntry> combinedEvent = new TreeMap<>(eventList);
        combinedEvent.putAll(archivedEventList);
        result.setEventList(combinedEvent);

        return result.findByName(toSearch);
    }

    @Override
    public CalendarList findToday() {
        CalendarListImpl result = new CalendarListImpl();

        Map<Integer, CalendarEntry> todayTasks = taskList.entrySet().stream()
                .filter(e -> e.getValue().isProperty(CalendarProperty.TODAY))
                .collect(Collectors.toMap(Entry::getKey, Entry::getValue));

        result.setTaskList(new TreeMap<>(todayTasks));

        Map<Integer, CalendarEntry> todayEvents = eventList.entrySet().stream()
                .filter(e -> e.getValue().isProperty(CalendarProperty.TODAY))
                .collect(Collectors.toMap(Entry::getKey, Entry::getValue));

        result.setEventList(new TreeMap<>(todayEvents));

        return result;
    }

    private CalendarEntry updateWithVisitor(EntryVisitor<OldNewEntryPair> visitor, int id) {
        CalendarEntry entryToEdit = delete(id);
        try {
            OldNewEntryPair pair = entryToEdit.accept(visitor);
            add(pair.newEntry);
            return pair.oldEntry;
        } catch (IllegalArgumentException ex) {
            add(entryToEdit);
            throw ex;
        }
    }

    private void filterByName(TreeMap<Integer, CalendarEntry> treeMap, String toSearch) {
        if (toSearch == null || toSearch.isEmpty()) {
            return;
        }
        Iterator<Map.Entry<Integer, CalendarEntry>> iterator = treeMap.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, CalendarEntry> entry = iterator.next();
            String entryName = entry.getValue().getName();
            if (!containsAnyWord(entryName, toSearch)) {
                iterator.remove();
            }
        }
    }

    private int getNextId() {
        int taskMax = getLastKey(this.taskList);
        int eventMax = getLastKey(this.eventList);
        int archivedTaskMax = getLastKey(this.archivedTaskList);
        int archivedEventMax = getLastKey(this.archivedEventList);
        int idToSet = maxId(taskMax, eventMax, archivedTaskMax, archivedEventMax) + 1;
        return idToSet;
    }

    private int getLastKey(TreeMap<Integer, CalendarEntry> treeMap) {
        int key = treeMap.isEmpty() ? BASE_ID : treeMap.lastKey();
        return key;
    }

    private int maxId(int taskMax, int eventMax, int archivedTaskMax, int archivedEventMax) {
        int maxId = Math.max(taskMax, eventMax);
        maxId = Math.max(maxId, archivedTaskMax);
        maxId = Math.max(maxId, archivedEventMax);
        return maxId;
    }

    private boolean isValidId(int id) {
        return id > BASE_ID && !isPresent(id);
    }

    private boolean isPresent(int id) {
        boolean isPresent = taskList.containsKey(id);
        isPresent |= eventList.containsKey(id);
        isPresent |= archivedTaskList.containsKey(id);
        isPresent |= archivedEventList.containsKey(id);
        return isPresent;
    }

    private List<CalendarEntry> sortByDateTime(CalendarProperty property, List<CalendarEntry> list) {
        Comparator<CalendarEntry> comparator = (CalendarEntry entry1, CalendarEntry entry2) -> {
            LocalDateTime date1 = entry1.getDateTime(property);
            LocalDateTime date2 = entry2.getDateTime(property);

            if (date1 == null && date2 == null) {
                return 0;
            } else if (date1 == null) {
                return 1;
            } else if (date2 == null) {
                return -1;
            } else if (date1.isBefore(date2)) {
                return -1;
            } else if (date1.isAfter(date2)) {
                return 1;
            } else {
                return 0;
            }
        };
        Collections.sort(list, comparator);
        return list;
    }

    private List<CalendarEntry> sortReverseByDateTime(CalendarProperty property, List<CalendarEntry> list) {
        List<CalendarEntry> sortedList = new ArrayList<CalendarEntry>();
        sortedList = sortByDateTime(property, list);
        Collections.reverse(sortedList);

        Comparator<CalendarEntry> comparator = (CalendarEntry entry1, CalendarEntry entry2) -> {
            LocalDateTime date1 = entry1.getDateTime(property);
            LocalDateTime date2 = entry2.getDateTime(property);

            if (date1 == null && date2 == null) {
                return 0;
            } else if (date1 == null) {
                return 1;
            } else if (date2 == null) {
                return -1;
            } else {
                return 0;
            }
        };

        Collections.sort(sortedList, comparator);

        return sortedList;
    }

    private boolean containsAnyWord(String entryName, String toSearch) {
        String[] toSearchArray = toSearch.split(" ");
        String[] entryNameArray = entryName.split(" ");
        for (String word1 : toSearchArray) {
            for (String word2 : entryNameArray) {
                if (isSimilar(word1, word2)) {
                    return true;
                }
            }
        }
        return false;
    }

    private boolean isSimilar(String word1, String word2) {
        return StringUtils.getJaroWinklerDistance(word1, word2) > WORD_SIMILARITY_THRESHOLD_INDEX;
    }

}
```
###### /src/lifetracker/calendar/CalendarProperty.java
``` java

/**
 * 
 * An enumeration to assist in extracting certain properties of an entry.
 * 
 */
public enum CalendarProperty {

    START, END, OVER, RECURRING, ONGOING, ACTIVE, TODAY, DATE_LIMIT, OCCURRENCE_LIMIT, DATE_LIMITED, OCCURRENCE_LIMITED;

}
```
###### /src/lifetracker/calendar/DeadlineTask.java
``` java

/**
 * 
 * Represents a task with a deadline.
 * 
 */
public class DeadlineTask extends GenericEntry {

    private LocalDateTime deadline;

    public DeadlineTask(String name, LocalDateTime deadline) {
        super(name);
        this.setDateTime(CalendarProperty.END, deadline);
        SERIAL_TYPE_IDENTIFIER = "DeadlineTask";
    }

    public DeadlineTask(DeadlineTask entry) {
        super(entry);
        this.setDateTime(CalendarProperty.END, entry.deadline);
        SERIAL_TYPE_IDENTIFIER = "DeadlineTask";
    }

    @Override
    public LocalDateTime getDateTime(CalendarProperty property) {
        if (property.equals(CalendarProperty.END)) {
            return this.deadline;
        } else {
            return super.getDateTime(property);
        }
    }

    @Override
    public void setDateTime(CalendarProperty property, LocalDateTime deadline) {
        if (property.equals(CalendarProperty.END)) {
            this.deadline = deadline;
        } else {
            super.setDateTime(property, deadline);
        }
    }

    @Override
    public boolean isProperty(CalendarProperty property) {
        switch (property) {
            case OVER :
                return LocalDateTime.now().isAfter(this.deadline);
            case ONGOING :
                return LocalDateTime.now().isBefore(this.deadline);
            case TODAY :
                return LocalDate.now().equals(this.deadline.toLocalDate());
            default :
                return super.isProperty(property);
        }
    }

    @Override
    public <T> T accept(EntryVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
```
###### /src/lifetracker/calendar/Event.java
``` java

/**
 * 
 * Represents an entry with a start and end date/time.
 * 
 */
public class Event extends DeadlineTask {

    private LocalDateTime startDateTime;

    public Event(String name, LocalDateTime start, LocalDateTime end) {
        super(name, end);
        CalendarEntry.checkStartBeforeEnd(start, end);
        this.startDateTime = start;
        SERIAL_TYPE_IDENTIFIER = "Event";
    }

    public Event(Event entry) {
        super(entry);
        this.startDateTime = entry.startDateTime;
        SERIAL_TYPE_IDENTIFIER = "Event";
    }

    @Override
    public LocalDateTime getDateTime(CalendarProperty property) {
        if (property.equals(CalendarProperty.START)) {
            return startDateTime;
        }
        return super.getDateTime(property);
    }

    @Override
    public void setDateTime(CalendarProperty property, LocalDateTime dateTime) {
        if (property.equals(CalendarProperty.START)) {
            CalendarEntry.checkStartBeforeEnd(dateTime, getDateTime(CalendarProperty.END));

            this.startDateTime = dateTime;
        } else {
            super.setDateTime(property, dateTime);
        }
    }

    @Override
    public boolean isProperty(CalendarProperty property) {
        switch (property) {
            case ONGOING :
                boolean hasStarted = LocalDateTime.now().isAfter(startDateTime);
                boolean isOver = isProperty(CalendarProperty.OVER);
                return hasStarted && !isOver;
            case TODAY :
                boolean startsToday = (LocalDate.now().equals(startDateTime.toLocalDate()));
                boolean isOngoing = isProperty(CalendarProperty.ONGOING);
                return startsToday || isOngoing;
            default :
                return super.isProperty(property);
        }
    }

    @Override
    public <T> T accept(EntryVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
```
###### /src/lifetracker/calendar/GenericEntry.java
``` java

/**
 * 
 * Represents an entry with only a name, without a deadline or start/end
 * date/time.
 * 
 */
public class GenericEntry implements CalendarEntry {

    protected String SERIAL_TYPE_IDENTIFIER = "GenericEntry";

    private static final String MESSAGE_ERROR_INVALID_COMMAND = "Invalid command!";

    private String name;
    private int id;
    private boolean isActive = true;

    public GenericEntry(String name) {
        this.name = name;
    }

    public GenericEntry(CalendarEntry entry) {
        this.name = entry.getName();
        this.id = entry.getId();
        this.isActive = entry.isProperty(CalendarProperty.ACTIVE);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public int getId() {
        return this.id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setId(int id) {
        this.id = id;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String getName() {
        return this.name;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setName(String name) {
        this.name = name;
    }

    /**
     * Returns {@code null} because a {@code GenericEntry} has no associated
     * {@code LocalDateTime}.
     * 
     * @param property
     *            An {@code enum} representing the desired property.
     * @return {@code null}.
     */
    @Override
    public LocalDateTime getDateTime(CalendarProperty property) {
        return null;
    }

    /**
     * Method not allowed for {@code GenericEntry} object.
     * 
     * @throws IllegalArgumentException
     */
    @Override
    public void setDateTime(CalendarProperty property, LocalDateTime dateTime) {
        throw new IllegalArgumentException(MESSAGE_ERROR_INVALID_COMMAND);
    }

    /**
     * Method not allowed for {@code GenericEntry} object.
     * 
     * @throws IllegalArgumentException
     */
    @Override
    public void setPeriod(Period period) {
        throw new IllegalArgumentException(MESSAGE_ERROR_INVALID_COMMAND);
    }

    /**
     * Returns {@code null} for {@code GenericEntry}.
     * 
     * @return {@code null}.
     */
    @Override
    public Period getPeriod() {
        return null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void toggleActive() {
        this.isActive = !this.isActive;
    }

    /**
     * Returns a {@code boolean} to indicate whether the entry satisfies the
     * specified property.
     * 
     * @param property
     *            An {@code enum} representing the desired property.
     * 
     * @return A {@code boolean} to indicate whether the entry satisfies the
     *         specified property.
     */
    @Override
    public boolean isProperty(CalendarProperty property) {
        switch (property) {
            case ONGOING :
                return true;
            case ACTIVE :
                return this.isActive;
            case OVER :
                return false;
            case TODAY :
                return true;
            default :
                return false;
        }
    }

    /**
     * A {@code GenericEntry} has no associated integer property (other than ID
     * number, which has its own getter).
     * 
     * @param property
     *            An {@code enum} representing the desired property.
     * @return 0.
     */
    @Override
    public int getIntegerProperty(CalendarProperty property) {
        return 0;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public <T> T accept(EntryVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
```
###### /src/lifetracker/calendar/RecurringEvent.java
``` java

/**
 * 
 * Represents a recurring event. The event can be defined to recur up to a
 * specified number of occurrences, or up to a specified date.
 *
 */
public class RecurringEvent extends RecurringTask {

    private LocalDateTime startDateTime;

    public RecurringEvent(String name, LocalDateTime start, LocalDateTime end, Period period) {
        super(name, end, period);
        CalendarEntry.checkStartBeforeEnd(start, end);
        startDateTime = start;
        SERIAL_TYPE_IDENTIFIER = "RecurringEvent";
    }

    public RecurringEvent(String name, LocalDateTime start, LocalDateTime end, Period period, int limit) {
        super(name, end, period, limit);
        CalendarEntry.checkStartBeforeEnd(start, end);
        startDateTime = start;
        SERIAL_TYPE_IDENTIFIER = "RecurringEvent";
    }

    public RecurringEvent(String name, LocalDateTime start, LocalDateTime end, Period period, LocalDate limit) {
        super(name, end, period, limit);
        CalendarEntry.checkStartBeforeEnd(start, end);
        startDateTime = start;
        SERIAL_TYPE_IDENTIFIER = "RecurringEvent";
    }

    public RecurringEvent(RecurringEvent entry) {
        super(entry);
        this.startDateTime = entry.startDateTime;
        SERIAL_TYPE_IDENTIFIER = "RecurringEvent";
    }

    @Override
    public LocalDateTime getDateTime(CalendarProperty property) {
        switch (property) {
            case START :
                return this.startDateTime;
            default :
                return super.getDateTime(property);
        }
    }

    @Override
    public void setDateTime(CalendarProperty property, LocalDateTime dateTime) {
        switch (property) {
            case START :
                // end date is always valid
                CalendarEntry.checkStartBeforeEnd(dateTime, this.getDateTime(CalendarProperty.END));
                this.startDateTime = dateTime;
                break;
            default :
                super.setDateTime(property, dateTime);
                break;
        }
    }

    @Override
    public boolean isProperty(CalendarProperty property) {
        switch (property) {
            case ONGOING :
                boolean hasStarted = LocalDateTime.now().isAfter(startDateTime);
                boolean isOver = isProperty(CalendarProperty.OVER);
                return hasStarted && !isOver;
            case TODAY :
                boolean startsToday = (LocalDate.now().equals(startDateTime.toLocalDate()));
                boolean isOngoing = isProperty(CalendarProperty.ONGOING);
                return startsToday || isOngoing;
            default :
                return super.isProperty(property);
        }
    }

    @Override
    public void updateToNext() {
        if (hasNext()) {
            this.startDateTime = startDateTime.plus(getPeriod());
            forceUpdateDate();
        }
    }

    @Override
    public boolean hasNext() {
        int occurrenceLimit = getIntegerProperty(CalendarProperty.OCCURRENCE_LIMIT);

        if (occurrenceLimit == INF_LIMIT_CONST) {
            return true;
        } else if (occurrenceLimit == DATE_LIMIT_CONST) {
            LocalDate newDate = getDateTime(CalendarProperty.START).toLocalDate().plus(getPeriod());
            LocalDate limit = getDateTime(CalendarProperty.DATE_LIMIT).toLocalDate();

            return newDate.isBefore(limit) || newDate.isEqual(limit);
        } else {
            return occurrenceLimit > 1;
        }
    }

    @Override
    public <T> T accept(EntryVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
```
###### /src/lifetracker/calendar/RecurringTask.java
``` java

/**
 * 
 * Represents a recurring task. The task can be defined to recur up to a
 * specified number of occurrences, or up to a specified date.
 *
 */
public class RecurringTask extends DeadlineTask {
    protected static final int INF_LIMIT_CONST = -1;
    protected static final int DATE_LIMIT_CONST = -2;
    private static final String MESSAGE_ERROR_NEGATIVE_LIMIT = "Number of occurrences must be positive!";
    private static final String MESSAGE_ERROR_INVALID_LIMIT_DATE = "Limit date cannot be before deadline/end date!";

    private Period period;
    private int occurrenceLimit;
    private LocalDate dateLimit;

    public RecurringTask(String name, LocalDateTime deadline, Period period) {
        super(name, deadline);
        this.period = period;
        this.occurrenceLimit = INF_LIMIT_CONST;
        SERIAL_TYPE_IDENTIFIER = "RecurringTask";
    }

    public RecurringTask(String name, LocalDateTime deadline, Period period, int limit) {
        super(name, deadline);
        this.period = period;
        if (limit <= 0) {
            throw new IllegalArgumentException(MESSAGE_ERROR_NEGATIVE_LIMIT);
        }
        this.occurrenceLimit = limit;
        SERIAL_TYPE_IDENTIFIER = "RecurringTask";
    }

    public RecurringTask(String name, LocalDateTime deadline, Period period, LocalDate limit) {
        super(name, deadline);
        if (limit.isBefore(deadline.toLocalDate())) {
            throw new IllegalArgumentException(MESSAGE_ERROR_INVALID_LIMIT_DATE);
        }
        this.period = period;
        this.dateLimit = limit;
        this.occurrenceLimit = DATE_LIMIT_CONST;
        SERIAL_TYPE_IDENTIFIER = "RecurringTask";
    }

    public RecurringTask(RecurringTask entry) {
        super(entry);
        this.period = entry.period;
        this.occurrenceLimit = entry.occurrenceLimit;
        this.dateLimit = entry.dateLimit;
        SERIAL_TYPE_IDENTIFIER = "RecurringTask";
    }

    @Override
    public LocalDateTime getDateTime(CalendarProperty property) {
        switch (property) {
            case DATE_LIMIT :
                if (occurrenceLimit == DATE_LIMIT_CONST) {
                    return this.dateLimit.atStartOfDay();
                } else {
                    return null;
                }
            default :
                return super.getDateTime(property);
        }
    }

    @Override
    public void setDateTime(CalendarProperty property, LocalDateTime dateTime) {
        switch (property) {
            case DATE_LIMIT :
                occurrenceLimit = DATE_LIMIT_CONST;
                if (dateTime.toLocalDate().isBefore(this.getDateTime(CalendarProperty.END).toLocalDate())) {
                    throw new IllegalArgumentException(MESSAGE_ERROR_INVALID_LIMIT_DATE);
                } else {
                    this.dateLimit = dateTime.toLocalDate();
                    this.occurrenceLimit = DATE_LIMIT_CONST;
                }
                break;
            case END :
                if (occurrenceLimit == DATE_LIMIT_CONST && this.dateLimit.isBefore(dateTime.toLocalDate())) {
                    throw new IllegalArgumentException(MESSAGE_ERROR_INVALID_LIMIT_DATE);
                }
                // Fallthrough
            default :
                super.setDateTime(property, dateTime);
        }
    }

    @Override
    public void setPeriod(Period period) {
        this.period = period;
    }

    @Override
    public Period getPeriod() {
        return period;
    }

    @Override
    public int getIntegerProperty(CalendarProperty property) {
        switch (property) {
            case OCCURRENCE_LIMIT :
                return occurrenceLimit;
            default :
                return super.getIntegerProperty(property);
        }
    }

    @Override
    public boolean isProperty(CalendarProperty property) {
        switch (property) {
            case RECURRING :
                return true;
            case DATE_LIMITED :
                return occurrenceLimit == DATE_LIMIT_CONST;
            case OCCURRENCE_LIMITED :
                return occurrenceLimit > 0;
            case ACTIVE :
                return true;
            default :
                return super.isProperty(property);
        }
    }

    public boolean hasNext() {
        if (this.occurrenceLimit == INF_LIMIT_CONST) {
            return true;
        } else if (this.occurrenceLimit == DATE_LIMIT_CONST) {
            LocalDate newDate = getDateTime(CalendarProperty.END).toLocalDate().plus(period);

            return newDate.isBefore(dateLimit) || newDate.isEqual(dateLimit);
        } else {
            return occurrenceLimit > 1;
        }
    }

    public void updateToNext() {
        if (hasNext()) {
            forceUpdateDate();
        }
    }

    public void setOccurrenceLimit(int n) {
        assert n > 0;
        occurrenceLimit = n;
    }

    public void removeLimit() {
        occurrenceLimit = INF_LIMIT_CONST;
    }

    protected void forceUpdateDate() {
        LocalDateTime currentDeadline = getDateTime(CalendarProperty.END);
        super.setDateTime(CalendarProperty.END, currentDeadline.plus(this.period));

        if (occurrenceLimit > 0) {
            occurrenceLimit--;
        }
    }

    @Override
    public <T> T accept(EntryVisitor<T> visitor) {
        return visitor.visit(this);
    }
}
```
###### /unused/CalendarEntryTest.java
``` java
//Test no longer works for new Calendar component
public class CalendarEntryTest {

    public static final LocalDateTime NOW = LocalDateTime.now();
    public static final LocalDateTime TWO_HOURS_FROM_NOW = LocalDateTime.now().plusHours(2);
    public static final LocalDateTime TWO_HOURS_AGO = LocalDateTime.now().minusHours(2);
    public static final LocalDateTime THIS_TIME_TOMORROW = LocalDateTime.now().plusDays(1);
    public static final LocalDateTime TWO_HOURS_FROM_NOW_TOMORROW = THIS_TIME_TOMORROW.plusHours(2);
    public static final LocalDateTime THIS_TIME_YESTERDAY = LocalDateTime.now().minusDays(1);
    public static final LocalDateTime THIS_TIME_TWO_DAYS_AGO = LocalDateTime.now().minusDays(2);
    public static final String TEST_NAME = "entry%d";
    static CalendarEntry testEntry1; // floating
    static CalendarEntry testEntry2; // ongoing deadline task due today
    static CalendarEntry testEntry3; // ongoing deadline task due tomorrow
    static CalendarEntry testEntry4; // overdue deadline task
    static CalendarEntry testEntry5; // ongoing event
    static CalendarEntry testEntry6; // upcoming event starting today
    static CalendarEntry testEntry7; // upcoming event starting tomorrow
    static CalendarEntry testEntry8; // event over
    static CalendarEntry testEntry9; // to test exceptions
    static CalendarEntry copyEntry1;
    static CalendarEntry copyEntry2;
    static CalendarEntry copyEntry8;

    static String getTestEntryName(int k) {
        return String.format(TEST_NAME, k);
    }

    @BeforeClass
    public static void setUpBeforeClass() throws Exception {

        testEntry1 = new CalendarEntryImpl(getTestEntryName(1), null, null, 1);
        testEntry2 = new CalendarEntryImpl(getTestEntryName(2), null, TWO_HOURS_FROM_NOW, 2);
        testEntry3 = new CalendarEntryImpl(getTestEntryName(3), null, THIS_TIME_TOMORROW, 3);
        testEntry4 = new CalendarEntryImpl(getTestEntryName(4), null, THIS_TIME_YESTERDAY, 4);
        testEntry5 = new CalendarEntryImpl(getTestEntryName(5), THIS_TIME_YESTERDAY, THIS_TIME_TOMORROW, 5);
        testEntry6 = new CalendarEntryImpl(getTestEntryName(6), TWO_HOURS_FROM_NOW, THIS_TIME_TOMORROW, 6);
        testEntry7 = new CalendarEntryImpl(getTestEntryName(7), THIS_TIME_TOMORROW, TWO_HOURS_FROM_NOW_TOMORROW, 7);
        testEntry8 = new CalendarEntryImpl(getTestEntryName(8), THIS_TIME_TWO_DAYS_AGO, THIS_TIME_YESTERDAY, 8);
        testEntry9 = null;
        copyEntry1 = testEntry1;
        copyEntry2 = testEntry2;
        copyEntry8 = testEntry8;
    }

    @Test
    public void testConstructor() {

        EntryType floating = EntryType.FLOATING;
        EntryType deadline = EntryType.DEADLINE;
        EntryType event = EntryType.EVENT;

        EntryType actualType1 = testEntry1.getType();
        EntryType actualType2 = testEntry2.getType();
        EntryType actualType3 = testEntry3.getType();
        EntryType actualType4 = testEntry4.getType();
        EntryType actualType5 = testEntry5.getType();
        EntryType actualType6 = testEntry6.getType();
        EntryType actualType7 = testEntry7.getType();
        EntryType actualType8 = testEntry8.getType();

        // test assignment of enum to entries
        assertEquals(floating, actualType1);
        assertEquals(deadline, actualType2);
        assertEquals(deadline, actualType3);
        assertEquals(deadline, actualType4);
        assertEquals(event, actualType5);
        assertEquals(event, actualType6);
        assertEquals(event, actualType7);
        assertEquals(event, actualType8);

        // test invalid construction of events
        try {
            testEntry9 = new CalendarEntryImpl(getTestEntryName(9), NOW, THIS_TIME_YESTERDAY, 9);
        } catch (Exception e) {

            String expectedErrorMessage = "Start date/time cannot be after end date/time!";

            assertEquals(IllegalArgumentException.class, e.getClass());
            assertEquals(expectedErrorMessage, e.getMessage());
        }
        // ensure that try block was not completed
        assertEquals(null, testEntry9);
    }

    @Test
    // test with null startTime (tasks) and non-null startTime (events)
    public void testGetStartTime() {

        LocalTime expectedStart1 = null;
        LocalTime expectedStart2 = null;
        LocalTime expectedStart3 = null;
        LocalTime expectedStart5 = THIS_TIME_YESTERDAY.toLocalTime();
        LocalTime expectedStart6 = TWO_HOURS_FROM_NOW.toLocalTime();
        LocalTime expectedStart7 = THIS_TIME_TOMORROW.toLocalTime();

        LocalTime actualStart1 = testEntry1.getStartTime();
        LocalTime actualStart2 = testEntry2.getStartTime();
        LocalTime actualStart3 = testEntry3.getStartTime();
        LocalTime actualStart5 = testEntry5.getStartTime();
        LocalTime actualStart6 = testEntry6.getStartTime();
        LocalTime actualStart7 = testEntry7.getStartTime();

        assertEquals(expectedStart1, actualStart1); // floating task
        assertEquals(expectedStart2, actualStart2); // deadline task
        assertEquals(expectedStart3, actualStart3); // deadline task
        assertEquals(expectedStart5, actualStart5); // event
        assertEquals(expectedStart6, actualStart6); // event
        assertEquals(expectedStart7, actualStart7); // event
    }

    @Test
    // test with null endTime (floating tasks) and non-null endTime (deadline
    // tasks, events)
    public void testGetEndTime() {

        LocalTime expectedEnd1 = null;
        LocalTime expectedEnd2 = TWO_HOURS_FROM_NOW.toLocalTime();
        LocalTime expectedEnd3 = THIS_TIME_TOMORROW.toLocalTime();
        LocalTime expectedEnd8 = THIS_TIME_YESTERDAY.toLocalTime();

        LocalTime actualEnd1 = testEntry1.getEndTime();
        LocalTime actualEnd2 = testEntry2.getEndTime();
        LocalTime actualEnd3 = testEntry3.getEndTime();
        LocalTime actualEnd8 = testEntry8.getEndTime();

        assertEquals(expectedEnd1, actualEnd1); // floating task
        assertEquals(expectedEnd2, actualEnd2); // deadline task
        assertEquals(expectedEnd3, actualEnd3); // deadline task
        assertEquals(expectedEnd8, actualEnd8); // event
    }

    @Test
    public void testIsToday() {

        assertFalse(testEntry1.isToday()); // false for floating tasks
        assertTrue(testEntry2.isToday()); // true for deadline tasks whose
                                          // deadline is today
        assertFalse(testEntry3.isToday()); // false for deadline tasks whose
                                           // deadline is not today
        assertFalse(testEntry4.isToday());
        assertTrue(testEntry5.isToday()); // true for ongoing events
        assertTrue(testEntry6.isToday()); // true for events that start today
        assertFalse(testEntry7.isToday()); // false for events not starting
                                           // today and not ongoing
        assertFalse(testEntry8.isToday()); // false for events that are over and
                                           // did not start today
    }

    @Test
    public void testIsOngoing() {

        assertTrue(testEntry1.isOngoing());
        assertTrue(testEntry2.isOngoing());
        assertFalse(testEntry4.isOngoing());
        assertTrue(testEntry5.isOngoing());
        assertFalse(testEntry6.isOngoing());
        assertFalse(testEntry8.isOngoing());
    }

    @Test
    public void testIsOver() {

        assertFalse(testEntry1.isOver());
        assertFalse(testEntry2.isOver());
        assertTrue(testEntry4.isOver());
        assertFalse(testEntry5.isOver());
        assertFalse(testEntry6.isOver());
        assertTrue(testEntry8.isOver());
    }

    @Test
    public void testEqualsCalendarEntry() {

        assertTrue(testEntry1.equals(copyEntry1));
        assertTrue(testEntry2.equals(copyEntry2));
        assertTrue(testEntry8.equals(copyEntry8));
    }

    @Test
    public void testCopy() {

        copyEntry1 = testEntry1.copy();
        copyEntry2 = testEntry2.copy();
        copyEntry8 = testEntry8.copy();

        assertTrue(testEntry1.equals(copyEntry1));
        assertTrue(testEntry2.equals(copyEntry2));
        assertTrue(testEntry8.equals(copyEntry8));
    }

}
```
